{"about":{"slug":"about","filePath":"about.md","title":"about","links":[],"tags":["blog"],"content":"这是关于作者页面","date":"2025-08-16T11:12:18.000Z"},"blog-with-obsidian-quartz4":{"slug":"blog-with-obsidian-quartz4","filePath":"blog-with-obsidian-quartz4.md","title":"使用Obisidian和Quartz 4编写博客","links":[],"tags":["blog"],"content":"安装和配置Quartz 4\ngit clone github.com/Kuhbz/quartz.git\ncd quartz\nnpm i\nnpx quartz create\n\n\n                  \n                  Warning\n                  \n                \n\n\n我安装的是我修改后配置好后的版本，如果要安装官方的版本请把仓库地址替换为：github.com/jackyzha0/quartz.git\n\n\n\n需要配置的插件\n\npriority: 用于查询日期信息的数据源。优先级最高。可能值为&quot;frontmatter&quot;、&quot;git&quot;和&quot;filesystem&quot;。默认为[&quot;frontmatter&quot;, &quot;git&quot;, &quot;filesystem&quot;]。如果您依赖git日期，请在quartz.config.ts设置defaultDateType设置modified。\nHardLineBreaks: 此插件会自动将 Markdown 文本中的单行换行符转换为 HTML 输出中的硬换行符。由于此插件不符合实际 Markdown 的语义，因此默认不启用。但如果您想与Obisidian保持一致，可以启用它。\n\n编写文章\n元数据\nQuartz 还允许在笔记中用Frontmatter的方式的附加元数据。\n---\ntitle: Example Title\ndraft: false\ntags:\n  - example-tag\n---\n \nThe rest of your content lives here. You can use **Markdown** here :)\n\nQuartz 原生支持的一些常见前置字段：\n\ntitle：页面标题。如果没有提供，Quartz 将使用文件名称作为标题。\ndescription：用于链接预览的页面描述。通常会被用在 SEO 的 meta 标签中，以及在文章列表或搜索结果中作为摘要显示\npermalink：页面的自定义 URL，即使文件路径发生变化也将保持不变。\naliases：此笔记的其他名称。这是一个字符串列表。\ntags：为页面打上一或多个标签。\ndraft：是否发布页面。\ndate：表示笔记发布日期的字符串。使用YYYY-MM-DD格式。\ncomments：设置为false则表示在本页不显示评论区。\n\n预览\nnpx quartz build --serve --concurrency 8\n要获得完整的帮助选项，可以运行npx quartz build --help。\n其中大多数都有合理的默认值，但是如果您有自定义设置，则可以覆盖它们：\n\n-d或--directory：内容文件夹。这通常只是content\n-v或--verbose：打印额外的日志信息\n-o或--output：输出文件夹。这通常只是public\n--serve：运行本地热重载服务器来预览你的 Quartz\n--port：在哪个端口上运行本地预览服务器\n--concurrency：使用多少个线程来解析笔记\n\n提交更改\nnpx quartz sync\n部署到Github Pages\n为了方便访问，我把生成的静态文件单独部署到kuhbz.github.io中，并且Giscus也使用这个仓库的discussions。\n1. 创建仓库\n&lt;你的用户名&gt;.github.io 是一个特殊的仓库，GitHub 会自动将它的 main (或 master) 分支部署为你的用户主页。如果这个仓库还不存在，请先在你的 GitHub 上创建它。网址就是 https://&lt;你的用户名&gt;.github.io。举例：我的用户名为kuhbz，那么仓库名就是kuhbz.github.io，访问地址就是kuhbz.github.io\n2. 生成并配置部署密钥\n为了让你当前仓库的 Action 能够安全地推送到 kuhbz.github.io 仓库，最安全的方法是使用部署密钥（Deploy Keys）。\n\n生成 SSH 密钥对：\n在你的本地电脑上打开终端，运行以下命令来生成一个新的 SSH 密钥对。当提示输入文件名时，可以输入 deploy_key，并且不要设置密码（直接按回车）。\nssh-keygen -t ed25519 -N &quot;&quot; -f deploy_key\n这会生成两个文件：deploy_key (私钥) 和 deploy_key.pub (公钥)。\n添加公钥到 kuhbz.github.io 仓库：\n\n打开 deploy_key.pub 文件，复制里面的全部内容。\n进入 kuhbz.github.io 仓库的 GitHub 页面。\n点击 “Settings” → “Deploy keys” → “Add deploy key”。\n给它一个标题，比如 “Quartz Deploy”。\n将公钥内容粘贴到 “Key” 字段中。\n非常重要：勾选 “Allow write access” 复选框。\n点击 “Add key”。\n\n\n添加私钥到你当前 Quartz 仓库：\n\n打开 deploy_key 文件（私钥），复制里面的全部内容。\n进入你存放 Quartz 源码的仓库的 GitHub 页面。\n点击 “Settings” → “Secrets and variables” → “Actions”。\n点击 “New repository secret”。\n将 Secret 的名字设置为 DEPLOY_KEY。\n将私钥内容粘贴到 “Secret” 字段中。\n点击 “Add secret”。\n\n\n\n3. 创建 deploy.yml 工作流\n现在，新建 .github/workflows/deploy.yml 文件。这个新版本的工作流使用了peaceiris/actions-gh-pages 这个流行的 Action 来处理跨仓库部署。\nname: Deploy Quartz site to kuhbz.github.io\n \non:\n  push:\n    branches:\n      - v4 # 确保这是你的源码主分支\n \njobs:\n  build-and-deploy:\n    runs-on: ubuntu-22.04\n    steps:\n      - name: Checkout source code\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0 # 获取所有git历史记录，用于日期等信息\n \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 22\n \n      - name: Install Dependencies\n        run: npm ci\n \n      - name: Build Quartz\n        run: npx quartz build\n \n      - name: Deploy to kuhbz.github.io\n        uses: peaceiris/actions-gh-pages@v4\n        with:\n          # 这是我们上一步创建的私钥Secret\n          deploy_key: ${{ secrets.DEPLOY_KEY }}\n          # 这是你的目标仓库\n          external_repository: kuhbz/kuhbz.github.io\n          # 这是要部署的文件夹\n          publish_dir: ./public\n          # 这是目标仓库的分支，对于用户主页通常是 main 或 master\n          publish_branch: main\n          # 确保 CNAME 文件被保留（如果你使用自定义域名）\n          keep_files: false\n          # 提交代码的用户名和邮箱\n          user_name: &#039;github-actions[bot]&#039;\n          user_email: &#039;github-actions[bot]@users.noreply.github.com&#039;\n          # 提交信息\n          commit_message: &quot;Deploy Quartz site from ${{ github.sha }}&quot;\n总结\n完成以上步骤后：\n运行 npx quartz sync 来提交并推送你的更改。推送会触 GitHub Actions 工作流。它会：\n\n构建你的 Quartz 网站，生成静态文件到 public 目录。\n使用你配置的部署密钥，安全地将 public 目录下的所有内容推送到 kuhbz.github.io 仓库的 main 分支。\n稍等片刻，网站就会成功部署在 kuhbz.github.io 上了。有需要的话也可以配置自定义域名。\n","date":"2025-08-18T05:53:08.000Z"},"claude-code-proxy-gemini-free-use":{"slug":"claude-code-proxy-gemini-free-use","filePath":"claude-code-proxy-gemini-free-use.md","title":"将Claude Code的请求代理到Gemini","links":[],"tags":["claude-code"],"content":"介绍\nCluade Code是目前最强的的AI编程工具，但是最低需要充值20美金/月才能使用。claude-code-proxy是一个代理服务器，可以将Claude Code的请求代理到Gemini或OpenAI。本文以代理到Gemini为例。\n具体步骤\n1. 安装Claude Code\nnpm install -g @anthropic-ai/claude-code\n2. 克隆代码\ngit clone github.com/1rgs/claude-code-proxy.git\ncd claude-code-proxy\n3. 安装 uv（如果还没有安装）：\ncurl -LsSf astral.sh/uv/install.sh | sh\n4. 配置环境变量：\n\n\n                  \n                  Suggestion\n                  \n                \n\n\n没有API KEY的话去Google AI Studio申请一个。\n\n\n\n新建.env文件，添加以下内容：\nOPENAI_BASE_URL=&quot;generativelanguage.googleapis.com/v1beta/openai/&quot;\nPREFERRED_PROVIDER=&quot;google&quot;\nBIG_MODEL=&quot;gemini-2.5-pro&quot;\nSMALL_MODEL=&quot;gemini-2.5-flash&quot;\nGEMINI_API_KEY=&quot;&lt;你的API KEY&gt;&quot;\n5. 启动代理服务器\nuv run uvicorn server:app --host 0.0.0.0 --port 8082\n6. 启动Claude\n ANTHROPIC_BASE_URL=http://localhost:8082 claude\n\n\n                  \n                  Tip\n                  \n                \n\n\n也可以配置ANTHROPIC_BASE_URL环境变量，然后直接用claude命令启动\n\n\n\n这样就是能正常使用：\n\n在这里可以看到具体调用了哪个模型，调用了多少次：\n","date":"2025-09-06T05:30:23.000Z"},"friends":{"slug":"friends","filePath":"friends.md","title":"友情链接","links":[],"tags":["blog"],"content":"互换友链请在这个页面留言。","date":"2025-08-16T11:12:18.000Z"},"python-basic-syntax":{"slug":"python-basic-syntax","filePath":"python-basic-syntax.md","title":"Python 基础","links":[],"tags":["python"],"content":"解释器\npython解释器通常以这几种方式执行代码：\n\n直接运行脚本文件（最常见）：\n\npython script.py [args]\n\n交互模式：命令行输入python进入交互模式。\n以字符串的方式传入:\n\n# 单行代码\npython -c &quot;print(&#039;Hello, World!&#039;)&quot;\n \n# 多行代码（分号分隔）\npython -c &quot;import sys; print(sys.version)&quot;\n\n以模块的方式执行：\n\npython -m module_name [args]\n\n管道：\n\necho &quot;print(1+1)&quot; | python\n基本数据类型\nPython 中只有六种基本数据类型：\n\nint\nfloat\ncomplex(复数)\nstr\nbool: True 或 False\nNoneType：只有一个值 None，表示空值或无值。\n\n控制流\n顺序结构\n代码从上到下逐行执行（这是默认的流程）。\n选择结构\nif语句\nif condition_1:\n    # 如果 condition_1 为 True，执行这里的代码\nelif condition_2:\n    # 如果 condition_1 为 False，但 condition_2 为 True，执行这里的代码\nelse:\n    # 如果以上所有条件都为 False，执行这里的代码\nmatch语句（3.10+）\n类似于其他语言中的 switch 语句，但功能更强大，提供了“结构化模式匹配”的能力。\n支持复杂的模式匹配，不仅匹配值，还能匹配数据结构、类型、甚至解构嵌套对象。\nmatch value:\n    case [x, y, z]:  # 匹配长度为3的列表\n        print(f&quot;列表: {x}, {y}, {z}&quot;)\n    case {&quot;key&quot;: val}:  # 匹配字典中的键\n        print(f&quot;字典值: {val}&quot;)\n    case int():  # 匹配类型\n        print(&quot;这是一个整数&quot;)\t\n\tcase _:  # 默认情况，相当于其他语言的default\n        print(&quot;未知命令&quot;)\n还有非常多的高阶用法。\n循环结构\nfor循环\nfor 变量 in 可迭代对象:\n    循环体\n通常会结合 range()生成数字序列，常用于指定循环次数。\nfor i in range(5):      # 0 到 4\n    print(i)\n \nfor i in range(1, 6):   # 1 到 5\n    print(i)\n \nfor i in range(0, 10, 2):  # 0, 2, 4, 6, 8（步长为2）\n    print(i)\nwhile循环\nwhile 条件:\n    循环体\n循环控制语句\n\nbreak：立即退出整个循环\n\nfor num in [1, 2, 3, 4, 5]:\n    if num == 3:\n        break\n    print(num)  # 输出: 1, 2\n\ncontinue：跳过当前迭代，进入下一次\n\nfor num in [1, 2, 3, 4, 5]:\n    if num == 3:\n        continue\n    print(num)  # 输出: 1, 2, 4, 5\n\nelse：循环正常结束后执行（未被 break 中断时）\n\nfor num in [1, 2, 3]:\n    print(num)\nelse:\n    print(&quot;循环完成&quot;)  # 会执行\n \nfor num in [1, 2, 3]:\n    if num == 2:\n        break\n    print(num)\nelse:\n    print(&quot;不会执行&quot;)  # 因为被 break 中断\n    \nfor num in [1, 2, 3]:  \n    if num == 3:  \n        continue  \n    print(num)  \nelse:  \n    print(&quot;会执行&quot;)  # 因为被 break 中断\n函数\n语法\ndef function_name(parameter1, parameter2, ...):\n    &quot;&quot;&quot;\n    这是一个文档字符串 (Docstring)，用来描述函数的功能。\n    &quot;&quot;&quot;\n    # 函数体 (Function Body)\n    # 在这里执行代码逻辑\n    return # 可选的返回值\n参数\n\n位置参数：调用时，实参的顺序必须与定义时参数的顺序一致。\n\ndef describe_pet(animal_type, pet_name):\n    print(f&quot;I have a {animal_type} named {pet_name}.&quot;)\n \ndescribe_pet(&quot;hamster&quot;, &quot;Harry&quot;) # &quot;hamster&quot; 对应 animal_type, &quot;Harry&quot; 对应 pet_name\n\n关键字参数: 调用时，通过 参数名=值 的形式指定实参，这样就无需关心顺序。\n\ndescribe_pet(pet_name=&quot;Willy&quot;, animal_type=&quot;whale&quot;) # 顺序可以颠倒\n\n默认参数: 定义函数时，可以为参数提供一个默认值。如果调用时没有为该参数提供值，就会使用默认值。\n\ndef greet(name, greeting=&quot;Hello&quot;):\n    print(f&quot;{greeting}, {name}!&quot;)\n \ngreet(&quot;Alice&quot;)               # 输出: Hello, Alice! (使用默认 greeting)\ngreet(&quot;Bob&quot;, greeting=&quot;Hi&quot;)  # 输出: Hi, Bob! (提供新的 greeting)\n\n可变数量的参数:  有时候你无法提前确定函数会接收多少个参数，这时可以使用 *args 和 **kwargs。\n\n\nargs: 它会将所有多余的位置参数收集到一个元组 (tuple) 中。\n\ndef sum_all(*numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nprint(sum_all(1, 2, 3))       # 输出: 6\nprint(sum_all(10, 20, 30, 40)) # 输出: 100\t\t\n\n\n**kwargs\n它会将所有多余的关键字参数收集到一个字典 (dictionary) 中。\n\ndef build_profile(first, last, **user_info):\n    &quot;&quot;&quot;创建一个字典，包含我们知道的关于用户的一切。&quot;&quot;&quot;\n    profile = {&#039;first_name&#039;: first, &#039;last_name&#039;: last}\n    profile.update(user_info) # 将 user_info 字典合并到 profile 中\n    return profile\n \nuser_profile = build_profile(&#039;albert&#039;, &#039;einstein&#039;,\n                             location=&#039;princeton&#039;,\n                             field=&#039;physics&#039;)\nprint(user_profile)\n# 输出: {&#039;first_name&#039;: &#039;albert&#039;, &#039;last_name&#039;: &#039;einstein&#039;, &#039;location&#039;: &#039;princeton&#039;, &#039;field&#039;: &#039;physics&#039;}\n\n\n                  \n                  Tips\n                  \n                \n\n一个函数定义中，参数的常规顺序是：  标准参数 → 默认参数 → *args → **kwargs\n返回值\n函数可以使用 return 语句返回一个或多个值。如果没有 return 语句，函数执行完毕后自动返回 None。\n返回单个值：\ndef square(number):\n    return number * number\n \nresult = square(4) # result is 16\n返回多个值： 实际上，Python 是将多个值打包成一个元组 (tuple) 返回。\ndef get_user_info():\n    name = &quot;Alex&quot;\n    age = 30\n    return name, age\n \nuser_name, user_age = get_user_info() # 这里是元组解包\nprint(f&quot;Name: {user_name}, Age: {user_age}&quot;) # 输出: Name: Alex, Age: 30\n \ninfo = get_user_info()\nprint(info) # 输出: (&#039;Alex&#039;, 30)\n数据结构\n列表 (List)\n\n定义: 一个有序的、可变的元素集合。\n特点:\n\n有序: 元素按插入的顺序存储，每个元素都有一个固定的索引。\n可变: 创建后可以随时添加、删除或修改其中的元素。\n**允许重复 **: 可以包含相同的元素。\n**异构性 **: 可以包含不同数据类型的元素（如数字、字符串、甚至其他列表）。\n\n\n适用场景: 当你需要一个会变化的有序集合时，比如存储用户的购物清单、文章的段落等。\n语法: 使用方括号 [] 定义。\n\n代码示例:\n# 创建列表\nfruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]\nprint(f&quot;原始列表: {fruits}&quot;)\n \n# 1. 访问元素 (通过索引)\nfirst_fruit = fruits[0]  # &quot;apple&quot;\nprint(f&quot;第一个水果: {first_fruit}&quot;)\n \n# 2. 修改元素\nfruits[1] = &quot;blackberry&quot;\nprint(f&quot;修改后: {fruits}&quot;) # [&#039;apple&#039;, &#039;blackberry&#039;, &#039;cherry&#039;]\n \n# 3. 添加元素\nfruits.append(&quot;date&quot;)      # 在末尾添加\nprint(f&quot;添加后: {fruits}&quot;)   # [&#039;apple&#039;, &#039;blackberry&#039;, &#039;cherry&#039;, &#039;date&#039;]\n \n# 4. 删除元素\nfruits.remove(&quot;apple&quot;)     # 删除指定值的元素\npopped_fruit = fruits.pop(1) # 删除指定索引的元素并返回它\nprint(f&quot;删除后: {fruits}&quot;)   # [&#039;blackberry&#039;]\nprint(f&quot;被弹出的水果: {popped_fruit}&quot;) # cherry\n\n元组 (Tuple)\n元组可以看作是“不可变的列表”。\n\n定义: 一个有序的、不可变的元素集合。\n特点:\n\n有序: 和列表一样，元素有固定顺序和索引。\n不可变: 一旦创建，就不能添加、删除或修改任何元素。\n允许重复: 和列表一样，可以包含重复元素。\n\n\n适用场景:\n\n当你有一组数据不希望被修改时，例如坐标点 (x, y)、RGB颜色值 (255, 0, 0)。\n作为字典的键（因为键必须是不可变的）。\n从函数返回多个值时，Python 默认会打包成元组。\n\n\n语法: 使用圆括号 () 定义。\n\n代码示例:\n# 创建元组\npoint = (10, 20)\ncolors = (&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;red&quot;)\n \n# 1. 访问元素\nx_coordinate = point[0]\nprint(f&quot;X坐标: {x_coordinate}&quot;)\n \n# 2. 尝试修改 (会报错!)\ntry:\n    point[0] = 15\nexcept TypeError as e:\n    print(f&quot;修改元组失败: {e}&quot;) # TypeError: &#039;tuple&#039; object does not support item assignment\n \n# 3. 元组解包 (Tuple Unpacking)\nname, age, city = (&quot;Alice&quot;, 30, &quot;New York&quot;)\nprint(f&quot;姓名: {name}, 年龄: {age}&quot;)\n\n字典 (Dictionary)\n字典是一种键值对的集合，非常适合用来存储映射关系。\n\n定义: 一个无序的（在 Python 3.7+ 版本中是有序的）、可变的键值对集合。\n特点:\n\n键值对: 每个元素都由一个唯一的“键”和一个“值”组成。\n键唯一且不可变: 字典中的键不能重复，且必须是不可变类型（如字符串、数字、元组）。\n可变: 可以随时添加、删除或修改键值对。\n有序性: 从 Python 3.7 开始，字典会记住元素的插入顺序。\n\n\n适用场景: 当你需要通过一个唯一的标识符（键）来查找、存储和更新相关信息时。例如，存储一个用户的个人信息、一本书的属性等。\n语法: 使用花括号 {} 定义，形式为 {key1: value1, key2: value2}。\n\n代码示例:\n# 创建字典\nperson = {\n    &quot;name&quot;: &quot;Bob&quot;,\n    &quot;age&quot;: 25,\n    &quot;city&quot;: &quot;Paris&quot;\n}\nprint(f&quot;原始字典: {person}&quot;)\n \n# 1. 访问值 (通过键)\nprint(f&quot;姓名: {person[&#039;name&#039;]}&quot;)\nprint(f&quot;年龄: {person.get(&#039;age&#039;)}&quot;) # .get()方法更安全，如果键不存在返回None\n \n# 2. 修改/添加键值对\nperson[&quot;age&quot;] = 26             # 修改已存在的键\nperson[&quot;job&quot;] = &quot;Engineer&quot;     # 添加新的键值对\nprint(f&quot;更新后: {person}&quot;)\n \n# 3. 删除键值对\ndel person[&quot;city&quot;]\nprint(f&quot;删除后: {person}&quot;)\n \n# 4. 遍历\nfor key, value in person.items():\n    print(f&quot;{key}: {value}&quot;)\n集合 (Set)\n\n定义: 一个无序的、可变的、不含重复元素的集合。\n特点:\n\n无序: 元素没有固定的顺序，你不能通过索引访问它们。\n不重复: 自动去除所有重复的元素。\n可变: 可以添加或删除元素。\n\n\n适用场景:\n\n去重: 快速去除列表或其他序列中的重复项。\n成员测试: 快速判断一个元素是否存在于集合中（比列表快得多）。\n数学运算: 执行交集 (&amp;)、并集 (|)、差集 (-) 等数学运算。\n\n\n语法: 使用花括号 {} 定义，但注意创建一个空集合必须用 set()，因为 {} 会创建一个空字典。\n\n代码示例:\n# 创建集合 (重复元素会被自动移除)\nnumbers = {1, 2, 3, 4, 3, 2}\nprint(f&quot;原始集合: {numbers}&quot;) # {1, 2, 3, 4}\n \n# 1. 添加和删除元素\nnumbers.add(5)\nnumbers.remove(2)\nprint(f&quot;修改后: {numbers}&quot;) # {1, 3, 4, 5}\n \n# 2. 成员测试 (非常快)\nprint(f&quot;3 是否在集合中? {3 in numbers}&quot;) # True\n \n# 3. 集合运算\nset_a = {1, 2, 3}\nset_b = {3, 4, 5}\n \nprint(f&quot;并集: {set_a | set_b}&quot;) # {1, 2, 3, 4, 5}\nprint(f&quot;交集: {set_a &amp; set_b}&quot;) # {3}\nprint(f&quot;差集: {set_a - set_b}&quot;) # {1, 2}\n\ncollections 模块\n当内置数据结构无法满足特定需求时，可以从 collections 模块中寻找更专业的工具。\n好的，遵照您的要求，以下是关于 Python 错误和异常的介绍，标题从二级标题开始。\n异常\n异常（Exception） 指的是在程序执行期间发生的错误事件。当 Python 解释器遇到一个它无法处理的情况时“抛出”一个异常。在程序中，如果没有处理异常，程序就会立即崩溃并退出。\n基本语法\ntry:\n\t# 可能出现异常的代码\nexcept ValueError:\n\t# ValueError 的处理逻辑\t\nexcept ZeroDivisionError:\n\t# ZeroDivisionError 的处理逻辑\nexcept Exception as e:\n\t# 捕获所有其他未预料到的异常，这是一个好习惯\n\tprint(f&quot;-&gt; EXCEPTION: 捕获到一个未预料的异常！类型: {type(e).__name__}, 信息: {e}&quot;)\nelse:\n\t# 如果 try 块中没有发生任何异常，则执行此块\n\tprint(&quot;-&gt; 进入 else 代码块，因为 try 中没有发生任何异常。&quot;)\t\nfinally:\n\t# 无论是否发生异常，这个块总是最后执行\n\tprint(&quot;-&gt; 进入 finally 代码块。这是必须执行的清理步骤。&quot;)\t\nexcept 指定的异常类型是抛出的异常本身，或者是它的父类。例如，except Exception 可以捕获 ValueError。\n主动抛出异常：\nraise ExceptionType(&quot;这里是描述错误信息的字符串&quot;)\n异常处理机制\n每当一个函数被调用，Python 就会在内存中创建一个“栈帧（Stack Frame）”。这个栈帧包含了该函数的局部变量、参数等信息。当一个函数执行完毕并返回时，它的栈帧就会被弹出（pop）。\n\n\n                  \n                  Example\n                  \n                \n\n\n\nmain.py 调用 function_A()，function_A 的栈帧被压入（push） 调用栈的顶部。\nfunction_A() 调用 function_B()，function_B 的栈帧被压入调用栈的顶部。\nfunction_B() 调用 function_C()，function_C 的栈帧被压入调用栈的顶部。\n\n\n\n\n此时的调用栈看起来像这样（从上到下）：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n栈顶 →function_C 的栈帧function_A 的栈帧main.py 的主模块异常处理过程遵循以下步骤：\n\n异常被抛出： 当一行代码出错（例如 1 / 0）或者被 raise 语句显式抛出时，Python 会创建一个异常对象**。这个对象包含了错误类型、错误信息等。同时，程序的正常执行立即停止。\n在当前作用域查找 try...except: Python 首先会在当前函数（也就是调用栈最顶端的那个栈帧）里查找，看抛出异常的代码是否被包裹在一个 try 块中。如果找到了 try 块：Python 会按顺序检查这个 try 块后面跟着的 except 子句。一旦找到匹配的 except 块，异常就被“捕获”了。异常的传递过程到此结束。如果没有找到任何匹配的 except 块，那么这个 try…except 结构就无法处理该异常。\n调用栈回溯： 如果在当前作用域没有找到能够处理该异常的 try…except 结构，Python 就会做一件事：它会销毁当前的栈帧（即从当前函数退出），然后将异常对象向上层传递，交给调用它的那个函数。这个过程被称为调用栈回溯。Python 会回到上一层函数（调用栈的下一个栈帧），在那个函数中，从它调用下一层函数的那一行代码开始，重复步骤 2 的过程。\n重复或最终崩溃： 这个“向上层传递并搜寻 except”的过程会一直持续下去，一层一层地回溯调用栈。如果在回溯的任何一层中，找到了能够处理该异常的 except 块，那么异常就被捕获，程序流程恢复正常。如果这个异常一路向上，回溯到了调用栈的最底层（全局作用域），仍然没有被任何 try…except 捕获，那么程序就会终止。Python 解释器会接手这个异常对象，并将异常的完整信息，包括一个叫做“Traceback”的东西，打印到屏幕上。Traceback 就是调用栈在异常发生那一刻的快照，它告诉你异常是如何一层层传递上来的。\n","date":"2025-09-01T06:59:24.000Z"},"wsl2-nat-mode-proxy-configuration-guide":{"slug":"wsl2-nat-mode-proxy-configuration-guide","filePath":"wsl2-nat-mode-proxy-configuration-guide.md","title":"WSL2 NAT模式代理配置指南","links":[],"tags":["wsl2","docker"],"content":"写在前面：为何回归 NAT 模式？\nWSL2 全新的 networkingMode=mirrored（镜像网络模式）在理论上提供了极大的便利，尤其是在 localhost 互通和局域网访问方面。然而，作为一项实验性功能，我在实践中遇到了许多难以排查的网络“坑”，尤其是在与 Docker 结合使用时，出现了连接被拒绝、代理不生效等一系列问题。\n在花费大量时间排错后，我决定回归到 WSL2 久经考验的默认 NAT 模式。这种模式虽然需要一些手动配置，但其行为是可预测且极其稳定的。\n本指南旨在为那些和我一样，选择从 mirrored 模式切换回 NAT 模式，或初次在 NAT 模式下配置代理的用户，提供一套完整、可靠的解决方案。本文将以在 Windows 主机上运行 Clash for Windows 代理程序为例，其默认端口为 7890。\n前置步骤：Windows 主机配置\n在配置 WSL 之前，必须确保 Windows 主机本身已准备就绪。\n1. 查找并固定主机局域网 IP\n代理服务器的目标地址必须固定。\n\n在 Windows PowerShell 或 CMD 中运行 ipconfig。\n在你的主网络适配器（如“以太网适配器”或“无线局域网适配器”）下找到 IPv4 地址。\n建议：在你的路由器管理后台，将此 IP 地址与你的电脑 MAC 地址进行绑定，以防止 IP 地址变动。\n\n\n\n                  \n                  本文将以 192.168.0.100 作为示例主机 IP，以 7890 作为 Clash for Windows 的代理端口。请在实际操作中替换为您自己的地址和端口。\n                  \n                \n\n2. 为代理端口添加入站防火墙规则\n这是最关键的一步。默认情况下，Windows 防火墙可能会阻止来自 WSL（即使它在内部网络）对主机端口的访问，特别是当网络被识别为“公用(Public)”时。创建一个精确的“允许”规则是解决此问题的最佳实践。\n\n在 Windows 搜索框中，输入“高级安全 Windows Defender 防火墙”并打开它。\n在左侧面板中，点击“入站规则”。\n在右侧“操作”面板中，点击“新建规则…”。\n在向导中，按以下步骤操作：\n\n规则类型：选择“端口”，点击“下一步”。\n协议和端口：选择“TCP”，然后在“特定本地端口”中输入您的代理端口，例如 7890。点击“下一步”。\n操作：选择“允许连接”，点击“下一步”。\n配置文件：全部勾选（“域”、“专用”、“公用”），以确保规则在任何网络环境下都生效。点击“下一步”。\n名称：为规则起一个易于识别的名称，例如 Allow WSL Clash Proxy (TCP 7890)。点击“完成”。\n\n\n\n\n\n                  \n                  IMPORTANT\n                  \n                \n\n\n如果不执行此步骤，即使后续所有配置都正确，来自 WSL 和 Docker 的连接也大概率会被 Windows 防火墙丢弃或拒绝。\n\n\n\n步骤一：为 WSL Shell 配置代理\n此配置将影响您在 WSL 终端中直接使用的命令，如 apt, curl, git, wget 等。\n\n编辑 Shell 配置文件。根据您的 Shell 类型选择：\n\n# 如果使用默认的 bash\nnano ~/.bashrc\n \n# 如果使用 zsh\nnano ~/.zshrc\n\n在文件末尾添加以下环境变量。我们同时添加小写和大写版本以获得最佳兼容性。\n\n# Proxy Configuration for Clash for Windows\nexport http_proxy=&quot;http://192.168.0.100:7890&quot;\nexport https_proxy=&quot;http://192.168.0.100:7890&quot;\nexport no_proxy=&quot;localhost,127.0.0.1&quot;\n \nexport HTTP_PROXY=&quot;http://192.168.0.100:7890&quot;\nexport HTTPS_PROXY=&quot;http://192.168.0.100:7890&quot;\nexport NO_PROXY=&quot;localhost,127.0.0.1&quot;\n\n应用配置。关闭并重开终端，或执行 source ~/.bashrc (或 source ~/.zshrc)。\n\n步骤二：为 Docker 环境配置代理\nDocker 的代理配置分为两部分：守护进程（Daemon）和构建/运行环境（Build/Container）。\n1. 配置 Docker 守护进程 (Daemon)\n此配置主要影响 docker pull, docker push 等与 Docker Hub 交互的命令。\n\n\n                  \n                  NOTE\n                  \n                \n\n\n直接修改 /etc/docker/daemon.json 是一种方法，但通过 systemd 的覆盖文件 (override) 是更推荐、更模块化的方式。\n\n\n\n\n使用以下命令，通过一条指令直接创建并写入 systemd 覆盖文件，以避免 vim 操作可能带来的问题。\n\nsudo mkdir -p /etc/systemd/system/docker.service.d/\nsudo tee /etc/systemd/system/docker.service.d/override.conf &gt; /dev/null &lt;&lt;EOF\n[Service]\nEnvironment=&quot;HTTP_PROXY=http://192.168.0.100:7890&quot;\nEnvironment=&quot;HTTPS_PROXY=http://192.168.0.100:7890&quot;\nEnvironment=&quot;NO_PROXY=localhost,127.0.0.1&quot;\nEOF\n\n应用配置并重启 Docker 服务。\n\n# 重新加载 systemd 配置\nsudo systemctl daemon-reload\n# 重启 Docker 服务以加载新的环境变量\nsudo systemctl restart docker\n2. 配置 Docker 构建与运行环境\n此配置影响 Dockerfile 中 RUN 指令（如 RUN apk add ...）以及 docker run 启动的容器内部的网络访问。\n\n修改 Dockerfile\n在 Dockerfile 的 FROM 指令之后，使用 ENV 指令明确设置代理环境变量。\n\nFROM alpine:3.19\n \n# 为构建过程设置代理\nENV HTTP_PROXY=&quot;http://192.168.0.100:7890&quot;\nENV HTTPS_PROXY=&quot;http://192.168.0.100:7890&quot;\nENV NO_PROXY=&quot;localhost,127.0.0.1&quot;\n \n# 现在 RUN 指令就可以通过代理下载软件包了\nRUN apk update &amp;&amp; apk add --no-cache curl git\n \n# ... 其他指令 ...\n\n为运行中的容器设置代理\n如果需要在 docker run 启动的容器内部也使用代理，可以通过 -e 参数传入环境变量。\n\ndocker run -it --rm \\\n  -e HTTP_PROXY=&quot;http://192.168.0.100:7890&quot; \\\n  -e HTTPS_PROXY=&quot;http://192.168.0.100:7890&quot; \\\n  ubuntu:latest \\\n  bash\n遵循以上步骤，即可在 WSL2 的标准 NAT 模式下，为你的开发环境建立一套稳定代理配置。","date":"2025-09-04T05:50:54.000Z"}}