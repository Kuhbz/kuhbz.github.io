{"about":{"slug":"about","filePath":"about.md","title":"about","links":[],"tags":["blog"],"content":"这是关于作者页面","date":"2025-08-16T11:12:18.000Z"},"articles/blog-with-obsidian-quartz4":{"slug":"articles/blog-with-obsidian-quartz4","filePath":"articles/blog-with-obsidian-quartz4.md","title":"使用Obisidian和Quartz 4编写博客","links":[],"tags":["blog"],"content":"安装和配置Quartz 4\ngit clone github.com/Kuhbz/quartz.git\ncd quartz\nnpm i\nnpx quartz create\n\n\n                  \n                  Warning\n                  \n                \n\n\n我安装的是我修改后配置好后的版本，如果要安装官方的版本请把仓库地址替换为：github.com/jackyzha0/quartz.git\n\n\n\n需要配置的插件\n\npriority: 用于查询日期信息的数据源。优先级最高。可能值为&quot;frontmatter&quot;、&quot;git&quot;和&quot;filesystem&quot;。默认为[&quot;frontmatter&quot;, &quot;git&quot;, &quot;filesystem&quot;]。如果您依赖git日期，请在quartz.config.ts设置defaultDateType设置modified。\nHardLineBreaks: 此插件会自动将 Markdown 文本中的单行换行符转换为 HTML 输出中的硬换行符。由于此插件不符合实际 Markdown 的语义，因此默认不启用。但如果您想与Obisidian保持一致，可以启用它。\n\n编写文章\n元数据\nQuartz 还允许在笔记中用Frontmatter的方式的附加元数据。\n---\ntitle: Example Title\ndraft: false\ntags:\n  - example-tag\n---\n \nThe rest of your content lives here. You can use **Markdown** here :)\n\nQuartz 原生支持的一些常见前置字段：\n\ntitle：页面标题。如果没有提供，Quartz 将使用文件名称作为标题。\ndescription：用于链接预览的页面描述。通常会被用在 SEO 的 meta 标签中，以及在文章列表或搜索结果中作为摘要显示\npermalink：页面的自定义 URL，即使文件路径发生变化也将保持不变。\naliases：此笔记的其他名称。这是一个字符串列表。\ntags：为页面打上一或多个标签。\ndraft：是否发布页面。\ndate：表示笔记发布日期的字符串。使用YYYY-MM-DD格式。\ncomments：设置为false则表示在本页不显示评论区。\n\n预览\nnpx quartz build --serve --concurrency 8\n要获得完整的帮助选项，可以运行npx quartz build --help。\n其中大多数都有合理的默认值，但是如果您有自定义设置，则可以覆盖它们：\n\n-d或--directory：内容文件夹。这通常只是content\n-v或--verbose：打印额外的日志信息\n-o或--output：输出文件夹。这通常只是public\n--serve：运行本地热重载服务器来预览你的 Quartz\n--port：在哪个端口上运行本地预览服务器\n--concurrency：使用多少个线程来解析笔记\n\n提交更改\nnpx quartz sync\n部署到Github Pages\n为了方便访问，我把生成的静态文件单独部署到kuhbz.github.io中，并且Giscus也使用这个仓库的discussions。\n1. 创建仓库\n&lt;你的用户名&gt;.github.io 是一个特殊的仓库，GitHub 会自动将它的 main (或 master) 分支部署为你的用户主页。如果这个仓库还不存在，请先在你的 GitHub 上创建它。网址就是 https://&lt;你的用户名&gt;.github.io。举例：我的用户名为kuhbz，那么仓库名就是kuhbz.github.io，访问地址就是kuhbz.github.io\n2. 生成并配置部署密钥\n为了让你当前仓库的 Action 能够安全地推送到 kuhbz.github.io 仓库，最安全的方法是使用部署密钥（Deploy Keys）。\n\n生成 SSH 密钥对：\n在你的本地电脑上打开终端，运行以下命令来生成一个新的 SSH 密钥对。当提示输入文件名时，可以输入 deploy_key，并且不要设置密码（直接按回车）。\nssh-keygen -t ed25519 -N &quot;&quot; -f deploy_key\n这会生成两个文件：deploy_key (私钥) 和 deploy_key.pub (公钥)。\n添加公钥到 kuhbz.github.io 仓库：\n\n打开 deploy_key.pub 文件，复制里面的全部内容。\n进入 kuhbz.github.io 仓库的 GitHub 页面。\n点击 “Settings” → “Deploy keys” → “Add deploy key”。\n给它一个标题，比如 “Quartz Deploy”。\n将公钥内容粘贴到 “Key” 字段中。\n非常重要：勾选 “Allow write access” 复选框。\n点击 “Add key”。\n\n\n添加私钥到你当前 Quartz 仓库：\n\n打开 deploy_key 文件（私钥），复制里面的全部内容。\n进入你存放 Quartz 源码的仓库的 GitHub 页面。\n点击 “Settings” → “Secrets and variables” → “Actions”。\n点击 “New repository secret”。\n将 Secret 的名字设置为 DEPLOY_KEY。\n将私钥内容粘贴到 “Secret” 字段中。\n点击 “Add secret”。\n\n\n\n3. 创建 deploy.yml 工作流\n现在，新建 .github/workflows/deploy.yml 文件。这个新版本的工作流使用了peaceiris/actions-gh-pages 这个流行的 Action 来处理跨仓库部署。\nname: Deploy Quartz site to kuhbz.github.io\n \non:\n  push:\n    branches:\n      - v4 # 确保这是你的源码主分支\n \njobs:\n  build-and-deploy:\n    runs-on: ubuntu-22.04\n    steps:\n      - name: Checkout source code\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0 # 获取所有git历史记录，用于日期等信息\n \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 22\n \n      - name: Install Dependencies\n        run: npm ci\n \n      - name: Build Quartz\n        run: npx quartz build\n \n      - name: Deploy to kuhbz.github.io\n        uses: peaceiris/actions-gh-pages@v4\n        with:\n          # 这是我们上一步创建的私钥Secret\n          deploy_key: ${{ secrets.DEPLOY_KEY }}\n          # 这是你的目标仓库\n          external_repository: kuhbz/kuhbz.github.io\n          # 这是要部署的文件夹\n          publish_dir: ./public\n          # 这是目标仓库的分支，对于用户主页通常是 main 或 master\n          publish_branch: main\n          # 确保 CNAME 文件被保留（如果你使用自定义域名）\n          keep_files: false\n          # 提交代码的用户名和邮箱\n          user_name: &#039;github-actions[bot]&#039;\n          user_email: &#039;github-actions[bot]@users.noreply.github.com&#039;\n          # 提交信息\n          commit_message: &quot;Deploy Quartz site from ${{ github.sha }}&quot;\n总结\n完成以上步骤后：\n运行 npx quartz sync 来提交并推送你的更改。推送会触 GitHub Actions 工作流。它会：\n\n构建你的 Quartz 网站，生成静态文件到 public 目录。\n使用你配置的部署密钥，安全地将 public 目录下的所有内容推送到 kuhbz.github.io 仓库的 main 分支。\n稍等片刻，网站就会成功部署在 kuhbz.github.io 上了。有需要的话也可以配置自定义域名。\n","date":"2025-09-07T00:00:00.000Z"},"articles/github-actions-docker-image-build":{"slug":"articles/github-actions-docker-image-build","filePath":"articles/github-actions-docker-image-build.md","title":"利用 GitHub Actions 自动化 Docker 镜像构建与 GHCR 推送","links":[],"tags":["claude-code"],"content":"背景\n由于国内网络环境的特殊性，使用 docker build 命令构建镜像成为了一件相当困难的事情。尤其是较大的镜像，即使已经配置了代理，仍然极易失败。我已经厌倦了反复处理这类问题，因此想到可以借助 GitHub Actions，让 GitHub 自动帮我们完成镜像的构建。虽然我此前也没有深入使用过 GitHub Actions，但得益于像 Claude Code 和 github-cli 这样的工具，我们完全可以轻松实现这一目标。\n前置准备\n\n安装Claude Code\n安装并配置了github-cli\n\n提示词\nultrathink 使用github-cli工具为我建立一个docker-builder仓库，这是对 docker-builder 仓库功能的一个简单、精炼的描述：\n  &quot;&quot;&quot;&quot;\n  docker-builder 仓库是一个中央化的、按需服务的 Docker 镜像构建中心。\n  它本身不包含任何具体的应用代码，其核心功能是提供一个通用的 GitHub Actions 工作流程，让你可以：\n  1.手动触发：通过在 GitHub 页面的表单中填写参数，来启动一个构建任务。\n  2.构建任何仓库：指定任何你有权访问的 GitHub 仓库地址、代码分支或标签。\n  3.灵活配置：定义要使用的 Dockerfile 路径和最终生成的镜像名称。\n  4.统一输出：将构建好的镜像自动推送到统一的 GitHub 容器镜像仓库 (GHCR) 中。\n  &quot;&quot;&quot;&quot;\n \n  下面是github-cli的使用文档:\n  &quot;&quot;&quot;\n $ gh -h\n  Work seamlessly with GitHub from the command line.\n \n  USAGE\n    gh &lt;command&gt; &lt;subcommand&gt; [flags]\n \n  CORE COMMANDS\n    auth:          Authenticate gh and git with GitHub\n    browse:        Open repositories, issues, pull requests, and more in the browser\n    codespace:     Connect to and manage codespaces\n    gist:          Manage gists\n    issue:         Manage issues\n    org:           Manage organizations\n    pr:            Manage pull requests\n    project:       Work with GitHub Projects.\n    release:       Manage releases\n    repo:          Manage repositories\n \n  GITHUB ACTIONS COMMANDS\n    cache:         Manage GitHub Actions caches\n    run:           View details about workflow runs\n    workflow:      View details about GitHub Actions workflows\n \n  ALIAS COMMANDS\n    co:            Alias for &quot;pr checkout&quot;\n \n  ADDITIONAL COMMANDS\n    alias:         Create command shortcuts\n    api:           Make an authenticated GitHub API request\n    attestation:   Work with artifact attestations\n    completion:    Generate shell completion scripts\n    config:        Manage configuration for gh\n    extension:     Manage gh extensions\n    gpg-key:       Manage GPG keys\n    label:         Manage labels\n    preview:       Execute previews for gh features\n    ruleset:       View info about repo rulesets\n    search:        Search for repositories, issues, and pull requests\n    secret:        Manage GitHub secrets\n    ssh-key:       Manage SSH keys\n    status:        Print information about relevant issues, pull requests, and notifications across repositories\n    variable:      Manage GitHub Actions variables\n \n  HELP TOPICS\n    accessibility: Learn about GitHub CLI&#039;s accessibility experiences\n    actions:       Learn about working with GitHub Actions\n    environment:   Environment variables that can be used with gh\n    exit-codes:    Exit codes used by gh\n    formatting:    Formatting options for JSON data exported from gh\n    mintty:        Information about using gh with MinTTY\n    reference:     A comprehensive reference of all gh commands\n \n  FLAGS\n    --help      Show help for command\n    --version   Show gh version\n \n  EXAMPLES\n    $ gh issue create\n    $ gh repo clone cli/cli\n    $ gh pr checkout 321\n \n  LEARN MORE\n    Use `gh &lt;command&gt; &lt;subcommand&gt; --help` for more information about a command.\n    Read the manual at cli.github.com/manual\n    Learn about exit codes using `gh help exit-codes`\n    Learn about accessibility experiences using `gh help accessibility`\n  &quot;&quot;&quot;\n剩下的工作交给Claude Code即可，在我的电脑上，Claude Code 一次性地、没有任何报错地完成了这个功能！\n效果展示\n仓库地址\n只要手动填入这些参数即可：\n\n成功构建了镜像：\n\n\n拉取镜像\n# 直接拉取\ndocker pull ghcr.io/kuhbz/iris:latest\n \n# 使用南京大学镜像加速（推荐） \ndocker pull ghcr.nju.edu.cn/kuhbz/iris:latest","date":"2025-09-22T00:00:00.000Z"},"articles/nicegui-quickstart":{"slug":"articles/nicegui-quickstart","filePath":"articles/nicegui-quickstart.md","title":"NiceGUI快速入门","links":["articles/python-basic-syntax"],"tags":["fullstack","NiceGUI"],"content":"工作原理与交互流程\n元素和控件\n在 NiceGUI中：\n\n元素 (Elements) 是构成用户界面 (UI) 的基本构建块。\n控件 (Controls) 是元素的一种，特指那些用户可以直接与之交互的元素。\n\n官方提供了非常多的元素和控件，包含各种使用场景，这一部分直接在官方文档中查找并选择我们需要的即可。\n布局\nwith会把后面的..作为一个容器：\n最基础的布局工具\n默认情况下，我们创建的每个元素都会像写文章一样，从上到下一个接一个地排列。ui.row 和 ui.column 可以改变这个默认行为。\n\nui.column: 元素在容器内从上到下垂直排列（这是默认行为，但显式使用 ui.column 可以更好地控制一组元素）。\nui.row: 元素在容器内从左到右水平排列。\n\n\n\n                  \n                  Important\n                  \n                \n\n在 NiceGUI 中，我们使用 Python 的 with 语句来定义一个容器的范围。所有在 with 代码块内创建的元素，都会被自动放入这个容器中(容器中的元素可以是任意的)。\n下面是一个简单的例子：\nfrom nicegui import ui  \n  \nwith ui.row():  \n    with ui.column():  \n        ui.button(&#039;1&#039;)  \n        ui.button(&#039;2&#039;)  \n  \n    with ui.column():  \n        ui.button(&#039;3&#039;)  \n        ui.button(&#039;4&#039;)  \nui.run()\n\n常用的几个布局工具\n官方文档中有非常多的布局工具，我们只要知道最常见的几个就可以，其他的要用到时候查一查文档。\n\nui.card: 它本质上是一个带有边框、阴影和内边距的容器，能让界面更有层次感。\n\n绑定属性\nNiceGUI 能够直接将 UI 元素绑定到模型(这里的模型必须是对象或者字典，不能是普通变量)。每个元素都提供类似bind_value和bind_visibility的方法，用于与相应的属性创建双向绑定。要定义单向绑定，请使用这些方法的_from和_to变体。\nfrom nicegui import ui\n \nclass Demo:\n    def __init__(self):\n        self.number = 1\n \ndemo = Demo()\nv = ui.checkbox(&#039;visible&#039;, value=True)\nwith ui.column().bind_visibility_from(v, &#039;value&#039;):\n    ui.slider(min=1, max=3).bind_value(demo, &#039;number&#039;)\n    ui.toggle({1: &#039;A&#039;, 2: &#039;B&#039;, 3: &#039;C&#039;}).bind_value(demo, &#039;number&#039;)\n    ui.number().bind_value(demo, &#039;number&#039;)\n \nui.run()\n绑定到变量\n如果需要绑定到变量，我们可以先用globals()获取一个包含所有全局变量的字典，然后再绑定。\nfrom nicegui import ui  \n  \ndate = &#039;2025-09-26&#039;  \nprint(globals())  \nui.label().bind_text_from(globals(), &#039;date&#039;)  \n  \nui.run()\n转换函数\n\nbackward: 当数据从数据模型流向 UI元素 时，backward函数会被调用。它接收来自模型的值，并返回一个处理过的新值以更新UI元素。\nforward: 当数据从 UI元素 流向数据模型 时，forward函数会被调用。它接收来自UI元素的值，并返回一个处理过的新值以更新数据模型。\n\nfrom nicegui import ui  \n  \ni = ui.input(value=&#039;Lorem ipsum&#039;)  \nui.label().bind_text_from(i, &#039;value&#039;,  \n                          backward=lambda text: f&#039;{len(text)} characters&#039;)  \n  \nui.run()\nfrom nicegui import ui  \n  \ndata = {&#039;text&#039;: &#039;Hello&#039;}  \n  \nui.input(label=&#039;Enter some text&#039;).bind_value_to(  \n    data, &#039;text&#039;,  \n    forward=lambda text: text.upper()  \n)  \n  \n  \nui.label().bind_text_from(data, &#039;text&#039;, backward=lambda text: f&quot;Model value is: {text}&quot;)  \n  \nui.run()\n绑定到存储\n绑定也适用于app.storage。\n行动与事件\n预定义事件\n对于预定义事件，比如说on_click等，我们直接给它传入一个可调用对象。\n\n\n                  \n                  Error\n                  \n                \n\n\n一个关键的错误观念要避免：\n你传递给 on_click 的不是函数执行后的结果，而是函数本身。\n\n\n\n看一个例子：\nfrom nicegui import ui  \n  \ndef show_message():  \n    ui.notify(&#039;你好！&#039;)  \n  \n# 这会立刻执行show_message()函数，显示通知，然后把函数的返回值 None 传给 on_click\n# 按钮点击时什么都不会发生，因为它的“任务”是 None\nui.button(&#039;错误的按钮&#039;, on_click=show_message())  \n  \n# 这里我们传递的是 show_message 这个函数对象本身  \n# 按钮收到了这个“任务”，并会在被点击时去执行它  \nui.button(&#039;正确的按钮&#039;, on_click=show_message)  \n  \nui.run()\n如果你的任务非常简单，只有一行代码，我们更应该使用lambda表达式。\nfrom nicegui import ui  \n  \n# 直接在 on_click 参数里定义一个临时的、匿名的任务  \nui.button(&#039;hello&#039;, on_click=lambda: ui.notify(&#039;你好！&#039;))  \n  \nui.run()\n这里的 lambda: ui.notify(...) 就创建了一个临时的、没有名字的可调用对象。这个函数对象本身被赋值给了 on_click 参数。\n通用事件\nNiceGUI 为最常见的事件提供了方便的快捷方式，比如 ui.button 的 on_click 参数和 ui.input 的 on_change 参数。这些是“专用接口”，简单直接。\n但是，前端世界（浏览器中的 JavaScript）有成百上千种不同的事件（比如鼠标移动、键盘按下、元素获得焦点、滚动、拖拽等等）。NiceGUI 的开发者不可能为每一种事件都创建一个专门的 on_... 参数。.on() 方法就是为了解决这个问题而生的。它允许你监听任何前端支持的事件，并将这个事件与后端的 Python 函数连接起来。\n\n\n                  \n                  Example\n                  \n                \n\n\n例子: 文档中的 mousemove (鼠标移动)。\n# ui.button 没有 on_mousemove 这个参数\n# 所以我们必须使用 .on() 来监听鼠标移动事件\n\n\n\nui.button(‘C’).on(‘mousemove’, lambda: ui.notify(‘You moved on button C.‘))\n\n\n\n我们初学者只需要了解这么多即可，大多数时候我们用预定义事件就够了。\n异步事件\n在处理耗时任务时，使用异步事件不会冻结UI，整个界面可以保持完全可交互。\n\n\n                  \n                  Tip\n                  \n                \n\n\n黄金法则：只要你的事件处理函数中包含任何可能耗时的I/O操作，就应该使用异步。\n以下是典型的应该使用异步事件的场景：\n\n网络请求\n数据库操作\n文件读写\n运行子进程执行外部命令并等待其完成\n\n\n\n\n这个版本展示了在等待时，另一个按钮依然可以点击:\nimport asyncio  \nfrom nicegui import ui  \n  \nasync def long_task():  \n    ui.notify(&#039;开始异步等待...&#039;)  \n    await asyncio.sleep(5)  \n    ui.notify(&#039;异步等待结束.&#039;)  \n  \nui.button(&#039;启动异步任务 (5s)&#039;, on_click=long_task)  \nui.button(&#039;点我测试响应&#039;, on_click=lambda: ui.notify(&#039;UI依然响应!&#039;))  \n  \nui.run()\n这个版本UI会被冻结，必须等同步等待结束后，另一个按钮才能被点击：\nimport time  \nfrom nicegui import ui  \n  \ndef long_task():  \n    ui.notify(&#039;开始同步等待...&#039;)  \n    time.sleep(5)  # 阻塞操作  \n    ui.notify(&#039;同步等待结束.&#039;)  \n  \nui.button(&#039;启动同步任务 (5s)&#039;, on_click=long_task)  \nui.button(&#039;点我测试响应&#039;, on_click=lambda: ui.notify(&#039;UI依然响应!&#039;))  \n  \nui.run()\n计时器\nNiceGUI 诞生的一个主要驱动力是需要一种简单的方法来定期更新界面，例如显示包含传入测量值的图表。计时器会以给定的间隔重复执行回调。\n参数：\n\ninterval: 调用计时器的间隔（可以在运行时更改）\ncallback: 间隔结束后执行的函数或协程\nactive: 是否应该执行回调（可以在运行时更改）\nonce: 回调是否仅在间隔指定的延迟后执行一次（默认值：False）\nimmediate: 是否应立即执行回调（默认值：True，如果once为True则忽略，在版本 2.9.0 中添加）\n\nfrom datetime import datetime\nfrom nicegui import ui\n \nlabel = ui.label()\nui.timer(1.0, lambda: label.set_text(f&#039;{datetime.now():%X}&#039;))\n \nui.run()\n使用timer.cancel取消计时器后，它将无法再被激活。\nfrom nicegui import ui\n \nslider = ui.slider(min=0, max=1, value=0.5)\ntimer = ui.timer(0.1, lambda: slider.set_value((slider.value + 0.01) % 1.0))\nui.switch(&#039;active&#039;).bind_value_to(timer, &#039;active&#039;)\nui.button(&#039;Cancel&#039;, on_click=timer.cancel)\n \nui.run()\n页面和路由\n私有页面（@ui.page装饰器）\n基本语法：\nfrom nicegui import ui  \n  \n@ui.page(&#039;/other_page&#039;, title=&#039;other_page&#039;)  \ndef other_page():  \n    ui.label(&#039;Welcome to the other side&#039;)  \n  \n@ui.page(&#039;/dark_page&#039;, dark=True)  \ndef dark_page():  \n    ui.label(&#039;Welcome to the dark side&#039;)  \n  \nui.link(&#039;Visit other page&#039;, other_page)  \nui.link(&#039;Visit dark page&#039;, dark_page)  \n  \nui.run()\n\n创建方式: 使用 @ui.page(&#039;/some_path&#039;) 装饰器来标记一个函数。\n核心特性: 每个用户（或每个浏览器标签页）访问时，都会独立执行一次这个函数，创建一个全新的、隔离的页面实例。\n适用场景: 需要为每个用户提供独立状态的页面，比如用户个人资料页、购物车等。\n\n每次访问都会发现页面是不同的uuid:\nfrom nicegui import ui\nfrom uuid import uuid4\n \n@ui.page(&#039;/private_page&#039;)\nasync def private_page():\n    ui.label(f&#039;private page with ID {uuid4()}&#039;)\n \nui.label(f&#039;shared auto-index page with ID {uuid4()}&#039;)\nui.link(&#039;private page&#039;, private_page)\n \nui.run()\n\n完整参数列表：\n\npath: 定义这个新页面的 URL 路由。这个值必须以斜杠 / 开头。例如，path=&#039;/products&#039; 会让这个页面在用户访问 http://your-server/products 时显示。\ntitle: (可选) 设置浏览器标签页上显示的标题。\nviewport: (可选) 设置页面 &lt;meta name=&quot;viewport&quot; ...&gt; 标签的内容，用于控制移动设备上的布局和缩放。\nfavicon: (可选) 设置浏览器标签页上的小图标。可以是一个相对文件路径或一个绝对 URL。如果未提供，则使用 NiceGUI 默认图标。\ndark: 控制此页面是否使用 Quasar 的暗黑模式。如果未设置，则遵循 ui.run() 命令的全局 dark 参数。\nlanguage: 设置页面的语言（例如 &#039;zh-CN&#039;）。如果未设置，则遵循 ui.run() 命令的全局 language 参数。\nresponse_timeout: 被装饰的页面构建函数允许执行的最长时间，默认为 3.0 秒。如果超时，将返回错误。\nreconnect_timeout: 服务器等待断开连接的浏览器重新连接的最长时间。如果未设置，则遵循 ui.run() 命令的全局 reconnect_timeout 参数。\napi_router: (高级用法) 指定一个自定义的 FastAPI APIRouter 实例来注册此页面路由，默认为 None 并使用默认路由器。\nkwargs: (高级用法) 传递额外的关键字参数给底层的 FastAPI 的 @app.get() 装饰器，用于 API 文档生成等高级配置。\n\n共享的自动索引页\n\n创建方式: 任何没有被 @ui.page 装饰器包裹的 UI 元素，都会被自动放置在根路径 / 的一个页面上。\n核心特性: 这个页面在服务器启动时只创建一次，所有连接到该服务器的用户看到的都是同一个页面实例。一个用户的操作会实时反映在所有其他用户的屏幕上。\n适用场景: 需要数据共享和实时协作的仪表盘（Dashboard）、聊天室、公共展示页面等。\n\n自动索引页面上显示的 ID 在浏览器重新加载页面时保持不变：\n代码示例\n页面布局\n你可以在任何页面（私有或共享）中添加复杂的布局元素，这些元素来自于 Quasar 框架：\n\nui.header: 在页面顶部创建固定的或可滚动的页眉。\nui.footer: 在页面底部创建页脚。\nui.left_drawer / ui.right_drawer: 创建左侧或右侧的抽屉式导航栏或菜单。\nui.page_sticky: 将元素“粘”在屏幕的特定位置。\n\nsub_pages\n注意：这是一个实验性功能，API 可能会发生变化。\n什么是单页应用 (SPA)?\n传统的网站，你每点击一个链接（比如从 / 到 /other），浏览器都会向服务器发送一个全新的请求，然后服务器返回一个完整的 HTML 页面，浏览器会整个刷新来显示新内容。\n而在单页应用中，当你点击链接时，页面不会整体刷新。相反，只有页面中需要变化的部分内容会被动态地替换掉。这通常是通过 JavaScript 在前端实现的，给用户的感觉是应用响应更快、更流畅，就像一个桌面应用。\nNiceGUI 的 ui.sub_pages 就是用来实现这个效果的工具。\n\n\n                  \n                  Question\n                  \n                \n\n这里等之后功能成熟了再来了解。\n参数注入\n得益于底层的 FastAPI，页面函数可以直接从 URL 中接收参数\n路径参数\nfrom nicegui import ui  \n  \nUser = {  \n    &quot;name&quot;: &quot;&quot;,  \n}  \n  \ndef handle_greet():  \n    ui.navigate.to(f&#039;/greet/{User[&quot;name&quot;]}&#039;)  \n  \n# 1. 定义一个页面，URL路径中的一部分 &#039;{name}&#039; 将作为参数  \n@ui.page(&#039;/greet/{name}&#039;)  \ndef greet_page(name: str):  \n    # 2. 函数的参数 &#039;name&#039; 会自动接收来自 URL 的值  \n    ui.label(f&#039;Hello, {name}!&#039;).classes(&#039;text-h4&#039;)  \n  \n  \nui.input().bind_value_to(User, &#039;name&#039;)  \nui.button(text=&#039;greet&#039;, on_click=handle_greet)  \n  \nui.run()\n查询参数\nfrom nicegui import ui  \n  \n# 1. 定义一个固定路径的页面  \n@ui.page(&#039;/add&#039;)  \ndef add_page(a: int, b: int):  \n    # 2. 函数参数 &#039;a&#039; 和 &#039;b&#039; 会自动从查询字符串中获取  \n    result = a + b  \n    ui.label(f&#039;{a} + {b} = {result}&#039;).classes(&#039;text-h4&#039;)  \n  \nui.run()\n浏览器与交互控制\n\n动态修改页面标题: 使用 ui.page_title(&#039;新标题&#039;) 可以在事件处理中随时改变当前页面的标题。\n浏览器历史导航 (ui.navigate):提供了一组函数来控制浏览器的行为：\n\nui.navigate.back(): 后退\nui.navigate.forward(): 前进\nui.navigate.reload(): 刷新\nui.navigate.to(&#039;URL&#039;):  可以将用户导航到任意内部或外部链接。\n\n\n触发文件下载 (ui.download): 提供了一组函数来让用户的浏览器下载文件：\n\nui.download.file(&#039;local_path.txt&#039;): 下载服务器上的本地文件。\nui.download.from_url(&#039;/logo.png&#039;): 下载服务器上已注册的静态资源。\nui.download.content(&#039;内容&#039;, &#039;文件名.txt&#039;): 将内存中的字符串或字节作为文件下载。\n\n\n\n静态资源与文件服务\n\n提供静态文件 (app.add_static_files):\n\n可以将服务器上的一个本地文件夹（如 images）映射到一个 URL 路径（如 /static）。\n这使得浏览器可以通过 /static/my_image.png 这样的 URL 访问到服务器上的文件，主要用于图片、CSS、JS 等文件。\n\n\n提供媒体文件 (app.add_media_files):\n\n与静态文件类似，但专门为音视频优化。\n它支持流式传输 (Streaming)，允许浏览器进行快进、拖动进度条等操作，这是 add_static_files 做不到的。\n\n\n\n将HTML添加到页面\n你可以通过调用ui.add_head_html or ui.add_body_html将HTML代码注入到页面，这对于添加自定义 CSS 样式或 JavaScript 代码非常有用。\nfrom nicegui import ui\n \nui.add_head_html(&#039;&#039;&#039;\n    &lt;style&gt;\n        .my-red-label {\n            color: Crimson;\n            font-weight: bold;\n        }\n    &lt;/style&gt;\n&#039;&#039;&#039;)\nui.label(&#039;RED&#039;).classes(&#039;my-red-label&#039;)\n \nui.run()\n编写API\nNiceGUI 基于FastAPI。这意味着你可以使用 FastAPI 的所有功能。例如，除了图形用户界面之外，还可以实现 RESTful API。只需要从nicegui导入app对象即可。\n你还可以在页面函数中返回任何其他 FastAPI 响应对象。例如，您可以返回一个，RedirectResponse以便在满足某些条件时将用户重定向到另一个页面。\nfrom nicegui import app, ui  \n  \n# 使用 @app.get 装饰器来定义一个 API 路由, 这和 FastAPI 的用法完全一样  \n@app.get(&#039;/api/hello&#039;)  \ndef hello_api():  \n    # 返回一个 Python 字典, FastAPI 会自动将其转换为 JSON 格式的响应  \n    return {&quot;message&quot;: &quot;Hello from the API!&quot;}  \n  \nui.run()\n样式控制\n在NiceGUI中，最简单的样式定义方式就是使用Tailwind CSS。Tailwind是一个“功能类优先”的CSS框架，你不需要写CSS代码，而是通过组合预设的类名来构建样式。NiceGUI对其提供了卓越的支持。\n在 NiceGUI 中，你有两种主要方式来使用 Tailwind工具类：\n\n.classes：一次性传入一个包含多个类的字符串，这是最接近原生 Tailwind HTML 写法的方式，非常适合直接从 Tailwind 官方文档或其他示例中复制代码。我们后面所有的示例都将只使用 .classes() 方法。\n\nui.label(&#039;Hello&#039;).classes(&#039;text-blue-500 font-bold&#039;)\n\n** .tailwind** ：链式调用，非常 Pythonic。\n\nui.label(&#039;Hello&#039;).tailwind.text_color(&#039;blue-400&#039;).font_size(&#039;5xl&#039;)\n安装和部署\n服务器托管\n打包成windows应用\nios/安卓(PWA)\n渐进式web应用，从浏览器直接“安装到桌面”。\n封装组件\n用函数封装\n用类封装\n将组件拆分到不同文件 (适用于大型项目)","date":"2025-09-29T00:00:00.000Z"},"articles/python-basic-syntax":{"slug":"articles/python-basic-syntax","filePath":"articles/python-basic-syntax.md","title":"Python 基础","links":[],"tags":["python"],"content":"解释器\npython解释器通常以这几种方式执行代码：\n\n直接运行脚本文件（最常见）：\n\npython script.py [args]\n\n交互模式：命令行输入python进入交互模式。\n以字符串的方式传入:\n\n# 单行代码\npython -c &quot;print(&#039;Hello, World!&#039;)&quot;\n \n# 多行代码（分号分隔）\npython -c &quot;import sys; print(sys.version)&quot;\n\n以模块的方式执行：\n\npython -m module_name [args]\n\n管道：\n\necho &quot;print(1+1)&quot; | python\n基本数据类型\nPython 中只有六种基本数据类型：\n\nint\nfloat\ncomplex(复数)\nstr\nbool: True 或 False\nNoneType：只有一个值 None，表示空值或无值。\n\n控制流\n顺序结构\n代码从上到下逐行执行（这是默认的流程）。\n选择结构\nif语句\nif condition_1:\n    # 如果 condition_1 为 True，执行这里的代码\nelif condition_2:\n    # 如果 condition_1 为 False，但 condition_2 为 True，执行这里的代码\nelse:\n    # 如果以上所有条件都为 False，执行这里的代码\nmatch语句（3.10+）\n类似于其他语言中的 switch 语句，但功能更强大，提供了“结构化模式匹配”的能力。\n支持复杂的模式匹配，不仅匹配值，还能匹配数据结构、类型、甚至解构嵌套对象。\nmatch value:\n    case [x, y, z]:  # 匹配长度为3的列表\n        print(f&quot;列表: {x}, {y}, {z}&quot;)\n    case {&quot;key&quot;: val}:  # 匹配字典中的键\n        print(f&quot;字典值: {val}&quot;)\n    case int():  # 匹配类型\n        print(&quot;这是一个整数&quot;)\t\n\tcase _:  # 默认情况，相当于其他语言的default\n        print(&quot;未知命令&quot;)\n还有非常多的高阶用法。\n循环结构\nfor循环\nfor 变量 in 可迭代对象:\n    循环体\n通常会结合 range()生成数字序列，常用于指定循环次数。\nfor i in range(5):      # 0 到 4\n    print(i)\n \nfor i in range(1, 6):   # 1 到 5\n    print(i)\n \nfor i in range(0, 10, 2):  # 0, 2, 4, 6, 8（步长为2）\n    print(i)\nwhile循环\nwhile 条件:\n    循环体\n循环控制语句\n\nbreak：立即退出整个循环\n\nfor num in [1, 2, 3, 4, 5]:\n    if num == 3:\n        break\n    print(num)  # 输出: 1, 2\n\ncontinue：跳过当前迭代，进入下一次\n\nfor num in [1, 2, 3, 4, 5]:\n    if num == 3:\n        continue\n    print(num)  # 输出: 1, 2, 4, 5\n\nelse：循环正常结束后执行（未被 break 中断时）\n\nfor num in [1, 2, 3]:\n    print(num)\nelse:\n    print(&quot;循环完成&quot;)  # 会执行\n \nfor num in [1, 2, 3]:\n    if num == 2:\n        break\n    print(num)\nelse:\n    print(&quot;不会执行&quot;)  # 因为被 break 中断\n    \nfor num in [1, 2, 3]:  \n    if num == 3:  \n        continue  \n    print(num)  \nelse:  \n    print(&quot;会执行&quot;)  # 因为被 break 中断\n函数\n语法\ndef function_name(parameter1, parameter2, ...):\n    &quot;&quot;&quot;\n    这是一个文档字符串 (Docstring)，用来描述函数的功能。\n    &quot;&quot;&quot;\n    # 函数体 (Function Body)\n    # 在这里执行代码逻辑\n    return # 可选的返回值\n参数\n\n位置参数：调用时，实参的顺序必须与定义时参数的顺序一致。\n\ndef describe_pet(animal_type, pet_name):\n    print(f&quot;I have a {animal_type} named {pet_name}.&quot;)\n \ndescribe_pet(&quot;hamster&quot;, &quot;Harry&quot;) # &quot;hamster&quot; 对应 animal_type, &quot;Harry&quot; 对应 pet_name\n\n关键字参数: 调用时，通过 参数名=值 的形式指定实参，这样就无需关心顺序。\n\ndescribe_pet(pet_name=&quot;Willy&quot;, animal_type=&quot;whale&quot;) # 顺序可以颠倒\n\n默认参数: 定义函数时，可以为参数提供一个默认值。如果调用时没有为该参数提供值，就会使用默认值。\n\ndef greet(name, greeting=&quot;Hello&quot;):\n    print(f&quot;{greeting}, {name}!&quot;)\n \ngreet(&quot;Alice&quot;)               # 输出: Hello, Alice! (使用默认 greeting)\ngreet(&quot;Bob&quot;, greeting=&quot;Hi&quot;)  # 输出: Hi, Bob! (提供新的 greeting)\n\n可变数量的参数:  有时候你无法提前确定函数会接收多少个参数，这时可以使用 *args 和 **kwargs。\n\n\nargs: 它会将所有多余的位置参数收集到一个元组 (tuple) 中。\n\ndef sum_all(*numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nprint(sum_all(1, 2, 3))       # 输出: 6\nprint(sum_all(10, 20, 30, 40)) # 输出: 100\t\t\n\n\n**kwargs\n它会将所有多余的关键字参数收集到一个字典 (dictionary) 中。\n\ndef build_profile(first, last, **user_info):\n    &quot;&quot;&quot;创建一个字典，包含我们知道的关于用户的一切。&quot;&quot;&quot;\n    profile = {&#039;first_name&#039;: first, &#039;last_name&#039;: last}\n    profile.update(user_info) # 将 user_info 字典合并到 profile 中\n    return profile\n \nuser_profile = build_profile(&#039;albert&#039;, &#039;einstein&#039;,\n                             location=&#039;princeton&#039;,\n                             field=&#039;physics&#039;)\nprint(user_profile)\n# 输出: {&#039;first_name&#039;: &#039;albert&#039;, &#039;last_name&#039;: &#039;einstein&#039;, &#039;location&#039;: &#039;princeton&#039;, &#039;field&#039;: &#039;physics&#039;}\n\n\n                  \n                  Tips\n                  \n                \n\n一个函数定义中，参数的常规顺序是：  标准参数 → 默认参数 → *args → **kwargs\n返回值\n函数可以使用 return 语句返回一个或多个值。如果没有 return 语句，函数执行完毕后自动返回 None。\n返回单个值：\ndef square(number):\n    return number * number\n \nresult = square(4) # result is 16\n返回多个值： 实际上，Python 是将多个值打包成一个元组 (tuple) 返回。\ndef get_user_info():\n    name = &quot;Alex&quot;\n    age = 30\n    return name, age\n \nuser_name, user_age = get_user_info() # 这里是元组解包\nprint(f&quot;Name: {user_name}, Age: {user_age}&quot;) # 输出: Name: Alex, Age: 30\n \ninfo = get_user_info()\nprint(info) # 输出: (&#039;Alex&#039;, 30)\nlambda表达式\n lambda 表达式是一种用于创建小型、一次性使用的匿名函数（没有名称的函数）的便捷方式lambda 表达式的语法非常直接明了：\n python  lambda arguments: expression  \n - lambda: 这是一个 Python 关键字，标志着一个 lambda 表达式的开始\n\narguments: 这是函数的参数列表，可以有零个或多个参数，参数之间用逗号分隔。\nexpression: 这是一个单行的表达式，函数会计算这个表达式的值并将其作为结果返回。\n\n\n\n                  \n                  Warning\n                  \n                \n\nlambda 函数只能包含一个表达式，不能包含复杂的语句块或 return 语句。\n数据结构\n列表 (List)\n\n定义: 一个有序的、可变的元素集合。\n特点:\n\n有序: 元素按插入的顺序存储，每个元素都有一个固定的索引。\n可变: 创建后可以随时添加、删除或修改其中的元素。\n**允许重复 **: 可以包含相同的元素。\n**异构性 **: 可以包含不同数据类型的元素（如数字、字符串、甚至其他列表）。\n\n\n适用场景: 当你需要一个会变化的有序集合时，比如存储用户的购物清单、文章的段落等。\n语法: 使用方括号 [] 定义。\n\n代码示例:\n# 创建列表\nfruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]\nprint(f&quot;原始列表: {fruits}&quot;)\n \n# 1. 访问元素 (通过索引)\nfirst_fruit = fruits[0]  # &quot;apple&quot;\nprint(f&quot;第一个水果: {first_fruit}&quot;)\n \n# 2. 修改元素\nfruits[1] = &quot;blackberry&quot;\nprint(f&quot;修改后: {fruits}&quot;) # [&#039;apple&#039;, &#039;blackberry&#039;, &#039;cherry&#039;]\n \n# 3. 添加元素\nfruits.append(&quot;date&quot;)      # 在末尾添加\nprint(f&quot;添加后: {fruits}&quot;)   # [&#039;apple&#039;, &#039;blackberry&#039;, &#039;cherry&#039;, &#039;date&#039;]\n \n# 4. 删除元素\nfruits.remove(&quot;apple&quot;)     # 删除指定值的元素\npopped_fruit = fruits.pop(1) # 删除指定索引的元素并返回它\nprint(f&quot;删除后: {fruits}&quot;)   # [&#039;blackberry&#039;]\nprint(f&quot;被弹出的水果: {popped_fruit}&quot;) # cherry\n\n元组 (Tuple)\n元组可以看作是“不可变的列表”。\n\n定义: 一个有序的、不可变的元素集合。\n特点:\n\n有序: 和列表一样，元素有固定顺序和索引。\n不可变: 一旦创建，就不能添加、删除或修改任何元素。\n允许重复: 和列表一样，可以包含重复元素。\n\n\n适用场景:\n\n当你有一组数据不希望被修改时，例如坐标点 (x, y)、RGB颜色值 (255, 0, 0)。\n作为字典的键（因为键必须是不可变的）。\n从函数返回多个值时，Python 默认会打包成元组。\n\n\n语法: 使用圆括号 () 定义。\n\n代码示例:\n# 创建元组\npoint = (10, 20)\ncolors = (&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;red&quot;)\n \n# 1. 访问元素\nx_coordinate = point[0]\nprint(f&quot;X坐标: {x_coordinate}&quot;)\n \n# 2. 尝试修改 (会报错!)\ntry:\n    point[0] = 15\nexcept TypeError as e:\n    print(f&quot;修改元组失败: {e}&quot;) # TypeError: &#039;tuple&#039; object does not support item assignment\n \n# 3. 元组解包 (Tuple Unpacking)\nname, age, city = (&quot;Alice&quot;, 30, &quot;New York&quot;)\nprint(f&quot;姓名: {name}, 年龄: {age}&quot;)\n\n字典 (Dictionary)\n字典是一种键值对的集合，非常适合用来存储映射关系。\n\n定义: 一个无序的（在 Python 3.7+ 版本中是有序的）、可变的键值对集合。\n特点:\n\n键值对: 每个元素都由一个唯一的“键”和一个“值”组成。\n键唯一且不可变: 字典中的键不能重复，且必须是不可变类型（如字符串、数字、元组）。\n可变: 可以随时添加、删除或修改键值对。\n有序性: 从 Python 3.7 开始，字典会记住元素的插入顺序。\n\n\n适用场景: 当你需要通过一个唯一的标识符（键）来查找、存储和更新相关信息时。例如，存储一个用户的个人信息、一本书的属性等。\n语法: 使用花括号 {} 定义，形式为 {key1: value1, key2: value2}。\n\n代码示例:\n# 创建字典\nperson = {\n    &quot;name&quot;: &quot;Bob&quot;,\n    &quot;age&quot;: 25,\n    &quot;city&quot;: &quot;Paris&quot;\n}\nprint(f&quot;原始字典: {person}&quot;)\n \n# 1. 访问值 (通过键)\nprint(f&quot;姓名: {person[&#039;name&#039;]}&quot;)\nprint(f&quot;年龄: {person.get(&#039;age&#039;)}&quot;) # .get()方法更安全，如果键不存在返回None\n \n# 2. 修改/添加键值对\nperson[&quot;age&quot;] = 26             # 修改已存在的键\nperson[&quot;job&quot;] = &quot;Engineer&quot;     # 添加新的键值对\nprint(f&quot;更新后: {person}&quot;)\n \n# 3. 删除键值对\ndel person[&quot;city&quot;]\nprint(f&quot;删除后: {person}&quot;)\n \n# 4. 遍历\nfor key, value in person.items():\n    print(f&quot;{key}: {value}&quot;)\n集合 (Set)\n\n定义: 一个无序的、可变的、不含重复元素的集合。\n特点:\n\n无序: 元素没有固定的顺序，你不能通过索引访问它们。\n不重复: 自动去除所有重复的元素。\n可变: 可以添加或删除元素。\n\n\n适用场景:\n\n去重: 快速去除列表或其他序列中的重复项。\n成员测试: 快速判断一个元素是否存在于集合中（比列表快得多）。\n数学运算: 执行交集 (&amp;)、并集 (|)、差集 (-) 等数学运算。\n\n\n语法: 使用花括号 {} 定义，但注意创建一个空集合必须用 set()，因为 {} 会创建一个空字典。\n\n代码示例:\n# 创建集合 (重复元素会被自动移除)\nnumbers = {1, 2, 3, 4, 3, 2}\nprint(f&quot;原始集合: {numbers}&quot;) # {1, 2, 3, 4}\n \n# 1. 添加和删除元素\nnumbers.add(5)\nnumbers.remove(2)\nprint(f&quot;修改后: {numbers}&quot;) # {1, 3, 4, 5}\n \n# 2. 成员测试 (非常快)\nprint(f&quot;3 是否在集合中? {3 in numbers}&quot;) # True\n \n# 3. 集合运算\nset_a = {1, 2, 3}\nset_b = {3, 4, 5}\n \nprint(f&quot;并集: {set_a | set_b}&quot;) # {1, 2, 3, 4, 5}\nprint(f&quot;交集: {set_a &amp; set_b}&quot;) # {3}\nprint(f&quot;差集: {set_a - set_b}&quot;) # {1, 2}\n\ncollections 模块\n当内置数据结构无法满足特定需求时，可以从 collections 模块中寻找更专业的工具。\n好的，遵照您的要求，以下是关于 Python 错误和异常的介绍，标题从二级标题开始。\n异常\n异常（Exception） 指的是在程序执行期间发生的错误事件。当 Python 解释器遇到一个它无法处理的情况时“抛出”一个异常。在程序中，如果没有处理异常，程序就会立即崩溃并退出。\n基本语法\ntry:\n\t# 可能出现异常的代码\nexcept ValueError:\n\t# ValueError 的处理逻辑\t\nexcept ZeroDivisionError:\n\t# ZeroDivisionError 的处理逻辑\nexcept Exception as e:\n\t# 捕获所有其他未预料到的异常，这是一个好习惯\n\tprint(f&quot;-&gt; EXCEPTION: 捕获到一个未预料的异常！类型: {type(e).__name__}, 信息: {e}&quot;)\nelse:\n\t# 如果 try 块中没有发生任何异常，则执行此块\n\tprint(&quot;-&gt; 进入 else 代码块，因为 try 中没有发生任何异常。&quot;)\t\nfinally:\n\t# 无论是否发生异常，这个块总是最后执行\n\tprint(&quot;-&gt; 进入 finally 代码块。这是必须执行的清理步骤。&quot;)\t\nexcept 指定的异常类型是抛出的异常本身，或者是它的父类。例如，except Exception 可以捕获 ValueError。\n主动抛出异常：\nraise ExceptionType(&quot;这里是描述错误信息的字符串&quot;)\n异常处理机制\n每当一个函数被调用，Python 就会在内存中创建一个“栈帧（Stack Frame）”。这个栈帧包含了该函数的局部变量、参数等信息。当一个函数执行完毕并返回时，它的栈帧就会被弹出（pop）。\n\n\n                  \n                  Example\n                  \n                \n\n\n\nmain.py 调用 function_A()，function_A 的栈帧被压入（push） 调用栈的顶部。\nfunction_A() 调用 function_B()，function_B 的栈帧被压入调用栈的顶部。\nfunction_B() 调用 function_C()，function_C 的栈帧被压入调用栈的顶部。\n\n\n\n\n此时的调用栈看起来像这样（从上到下）：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n栈顶 →function_C 的栈帧function_A 的栈帧main.py 的主模块异常处理过程遵循以下步骤：\n\n异常被抛出： 当一行代码出错（例如 1 / 0）或者被 raise 语句显式抛出时，Python 会创建一个异常对象**。这个对象包含了错误类型、错误信息等。同时，程序的正常执行立即停止。\n在当前作用域查找 try...except: Python 首先会在当前函数（也就是调用栈最顶端的那个栈帧）里查找，看抛出异常的代码是否被包裹在一个 try 块中。如果找到了 try 块：Python 会按顺序检查这个 try 块后面跟着的 except 子句。一旦找到匹配的 except 块，异常就被“捕获”了。异常的传递过程到此结束。如果没有找到任何匹配的 except 块，那么这个 try…except 结构就无法处理该异常。\n调用栈回溯： 如果在当前作用域没有找到能够处理该异常的 try…except 结构，Python 就会做一件事：它会销毁当前的栈帧（即从当前函数退出），然后将异常对象向上层传递，交给调用它的那个函数。这个过程被称为调用栈回溯。Python 会回到上一层函数（调用栈的下一个栈帧），在那个函数中，从它调用下一层函数的那一行代码开始，重复步骤 2 的过程。\n重复或最终崩溃： 这个“向上层传递并搜寻 except”的过程会一直持续下去，一层一层地回溯调用栈。如果在回溯的任何一层中，找到了能够处理该异常的 except 块，那么异常就被捕获，程序流程恢复正常。如果这个异常一路向上，回溯到了调用栈的最底层（全局作用域），仍然没有被任何 try…except 捕获，那么程序就会终止。Python 解释器会接手这个异常对象，并将异常的完整信息，包括一个叫做“Traceback”的东西，打印到屏幕上。Traceback 就是调用栈在异常发生那一刻的快照，它告诉你异常是如何一层层传递上来的。\n\n异步\n同步和异步的概念\n\n同步 (Synchronous)：代码一行一行地执行，一个任务必须等待上一个任务完成后才能开始。如果某个任务需要很长时间（比如等待网络响应），整个程序就会被“阻塞”，停在那里不动。\n异步 (Asynchronous)：程序在执行一个耗时操作时（如文件下载、数据库查询），不会傻等，而是会切换去做其他任务，等那个耗时操作完成后再回过头来处理结果。\n\nasyncio\nPython 3.4 版本引入了 asyncio 模块，为异步编程提供了标准库支持。 后来在 Python 3.5 中引入了 async 和 await 关键字，使得异步代码的编写更加简洁直观。\n几个关键概念：\n\n事件循环 (Event Loop)：异步编程的核心，可以理解为一个“调度员”。它负责管理和调度所有待执行的任务，当一个任务在等待I/O时，事件循环会把它挂起，然后去执行其他可以执行的任务。\n协程 (Coroutine)：使用 async def 定义的函数就是一个协程函数。调用它不会立即执行，而是返回一个协程对象。协程可以在执行过程中被暂停和恢复。\nawait：这个关键字只能用在 async def 函数内部。它的作用是“暂停”当前协程的执行，等待其后的异步操作完成。在等待期间，事件循环会去执行其他任务。\n任务 (Task)：通过 asyncio.create_task() 等函数将协程包装成一个任务，任务才能被事件循环调度执行。\n\n简单示例\n同步代码：\nimport time  \n  \ndef say_after(delay, what):  \n    time.sleep(delay)  \n    print(what)  \n  \ndef main():  \n    start_time = time.time()  \n    say_after(1, &#039;hello&#039;)  \n    say_after(1, &#039;world&#039;)  \n    say_after(1, &#039;!&#039;)  \n    end_time = time.time()  \n    print(f&quot;总耗时: {end_time - start_time:.2f} 秒&quot;)  \n  \nmain()\n结果：\nhello\nworld\n!\n总耗时: 3.00 秒\n异步代码：\nimport asyncio  \nimport time  \n  \n# 使用 async def 定义一个协程函数  \nasync def say_after(delay, what):  \n    # 使用 await 等待一个异步操作  \n    await asyncio.sleep(delay)  \n    print(what)  \n  \nasync def main():  \n    start_time = time.time()  \n  \n    # 使用 asyncio.gather() 并发运行多个任务  \n    await asyncio.gather(  \n        say_after(1, &#039;hello&#039;),  \n        say_after(1, &#039;world&#039;),  \n        say_after(1, &#039;!&#039;)  \n    )  \n  \n    end_time = time.time()  \n    print(f&quot;总耗时: {end_time - start_time:.2f} 秒&quot;)  \n  \n# 使用 asyncio.run() 来启动顶层异步函数 mainasyncio.run(main())\n结果\nhello\nworld\n!\n总耗时: 1.01 秒\n在这个例子中，asyncio.gather 会同时启动三个 say_after 任务。当第一个任务遇到 await asyncio.sleep(1) 时，它会“告诉”事件循环“我要在这里等1秒，你可以先去做别的”。事件循环就会去启动第二个和第三个任务。因为这三个任务都是在同一时间开始等待，所以总耗时大约就是最长的那个任务的等待时间。","date":"2025-09-10T00:00:00.000Z"},"articles/sqlmodel-crud-quickstart":{"slug":"articles/sqlmodel-crud-quickstart","filePath":"articles/sqlmodel-crud-quickstart.md","title":"SQLModel 快速入门","links":[],"tags":["SQLModel","fullstack"],"content":"对于一名新手程序员来说，学习数据库操作最快的方法是理解其三个核心层次：\n\n数据库级操作：如何连接、创建或删除整个数据库。\n表级操作：如何在数据库中创建或删除表的结构。\n数据级操作：如何对表中的数据进行增、删、改、查 (CRUD)。\n\nSQLModel 是一个现代化的 Python ORM 库，它能让你用 Python 代码优雅地完成上述大部分任务，尤其是表和数据级的操作。\n\n第一部分：数据库级操作\nORM 的主要工作不是管理数据库服务器，而是与一个已经存在的数据库进行交互。因此，连接数据库是核心，而创建和删除通常是环境准备工作。\n1. 连接数据库\n在 SQLModel 中，“选择”一个数据库意味着创建一个指向它的“引擎”(Engine)。这是通过一个特殊的连接字符串 (URL) 完成的。\n\n\nAPI: create_engine()\n\n\n连接字符串格式: 数据库类型://用户名:密码@主机:端口/数据库名\n\n\nfrom sqlmodel import create_engine\n \n# 示例 1: 连接到一个本地的 PostgreSQL 数据库，名为 &quot;mydb&quot;\n# 需要先安装 psycopg2: pip install psycopg2-binary\npg_engine = create_engine(&quot;postgresql://myuser:mypassword@localhost/mydb&quot;)\n \n# 示例 2: 连接到一个 SQLite 数据库文件\n# SQLite 是一个文件型数据库，如果文件不存在，会在首次操作时自动创建\nsqlite_engine = create_engine(&quot;sqlite:///database.db&quot;)\n\n\n                  \n                  关键点 \n                  \n                \n\n\n你的所有后续操作都将通过这个 engine 对象在指定的数据库上执行。\n\n\n\n2. 创建数据库\n\n对于 SQLite: 如上所示，当你使用 create_engine 指向一个不存在的文件时，该文件（即数据库）会被自动创建。\n对于 PostgreSQL: 推荐在应用程序之外，使用数据库管理工具手动创建。也可以在终端运行 createdb my_new_database。\n\n3. 删除数据库\n\n对于 SQLite: 直接删除数据库文件即可。\nimport os\nif os.path.exists(&quot;database.db&quot;):\n    os.remove(&quot;database.db&quot;)\n\n对于 PostgreSQL: 同样，推荐使用管理工具。或在终端运行 dropdb my_database_to_delete\n\n\n第二部分：表级操作\n这是 SQLModel 强大之处。你通过定义 Python 类来定义数据表的结构。SQLModel 的设计强制要求使用类型提示语法来定义字段，但是对于初学者，完全可以在理解上暂时忽略 Pydantic 的数据校验功能和类型提示的深层含义。我们可以把冒号和后面的类型当作一个固定的写法，这个写法只有一个目的：告诉数据库，这一列应该是什么类型。\n1. 定义表模型\n每个继承了 SQLModel 的类，如果设置 table=True，就对应数据库中的一张表。\nfrom typing import Optional\nfrom sqlmodel import Field, SQLModel\n \nclass Hero(SQLModel, table=True):\n    # 类名 &quot;Hero&quot; 会被自动转换为表名 &quot;hero&quot;\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str = Field(index=True)\n    secret_name: str\n    age: Optional[int] = Field(default=None)\n\n这里的id、name、secret_name 、age 对应数据库中的列名。\n: 后面的内容指定列的类型。比如\n\nOptional[int]: 我们告诉数据库，这一列要存整数，并且可以为空。\nstr: 我们告诉数据库，这一列要存文本。\n\n\nField() 的作用：为列提供额外的元数据，这些元数据会被 SQLModel 用来精确地配置数据库表中对应列的 schema（结构、约束和行为）。\n\n虽然 Field()有很多参数，但在日常开发中，只需要掌握几个最核心的就足够了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n参数 (Parameter)作用 (Function)使用场景示例 (Example Use Case)primary_key=True将列设为主键，作为每行数据的唯一标识。用于每张表的唯一 IDdefault=...设置一个静态的默认值。新用户默认为激活状态unique=True保证该列中的所有值都是唯一的。确保每个用户的邮箱都是唯一的index=True为该列创建数据库索引以加快查询速度。如果经常需要按名字搜索foreign_key=&quot;...&quot;将列设为外键，关联到另一张表的列。在文章表中关联作者max_length=...限制字符串类型的最大长度。限制用户名长度default_factory=...提供一个函数，用于动态生成默认值。记录精确的创建时间nullable=...显式声明该列是否可以为 NULL（空）。通常由 Optional[...] 类型自动推断，很少需要手动设置\n2. 创建表\nSQLModel 会收集所有你定义的模型，然后你可以用一条命令在数据库中创建所有对应的表。\n\nAPI: SQLModel.metadata.create_all(engine)\n\n\n\n                  \n                  安全的命令 \n                  \n                \n\n\n这个命令是安全的，可以重复执行。它会先检查表是否存在，只创建那些不存在的表。\n\n\n\n# (接上文的 Hero 模型和 sqlite_engine)\n \ndef create_tables():\n    print(&quot;开始创建表...&quot;)\n    # 这条命令会连接到数据库，并创建 Hero 表\n    SQLModel.metadata.create_all(sqlite_engine)\n    print(&quot;表创建完成。&quot;)\n \n# 在你的应用启动时调用一次即可\ncreate_tables()\n3. 删除表\n\nAPI: SQLModel.metadata.drop_all(engine)\n\n\n\n                  \n                  危险操作 \n                  \n                \n\n\n这是一个危险的操作，它会删除所有定义的表以及表中的全部数据。通常只在测试或开发初期重置数据库时使用。\n\n\n\ndef delete_tables():\n    print(&quot;警告：即将删除所有表...&quot;)\n    SQLModel.metadata.drop_all(sqlite_engine)\n    print(&quot;所有表已删除。&quot;)\n关于修改表结构 (数据库迁移)\n如果你的 Hero 模型已经创建了对应的表，之后你又给模型增加了一个新字段（比如 hometown: str），再次运行 create_all 是不会更新表结构的。这时你需要专业的数据库迁移工具，例如 Alembic。对于初学者，可以先了解这个概念，在项目需要时再深入学习。\n\n第三部分：数据级操作 (增删改查 - CRUD)\n这是日常开发中最频繁的操作。所有这些操作都在一个“会话”(Session) 中进行。Session 对象是用来管理事务（Transaction）的。最常使用的·with Session(engine) as session: 代码块，其整体就代表了一个数据库事务。\n准备工作\n在我们可以对数据进行增删改查之前，必须先完成两项基础准备工作：\n\n建立与数据库的连接：通过 create_engine() 创建一个引擎 engine。\n确保数据表已存在：通过 SQLModel.metadata.create_all(engine) 确保代码中定义的模型（如 Hero）已经在数据库中创建了对应的表。\n\n只有在这两项准备工作完成后，我们才能开始创建 Session 对象来执行具体的数据操作。\nfrom sqlmodel import Session\n \n# engine 来自第一部分\nengine = create_engine(&quot;sqlite:///database.db&quot;)\n \n# 创建 Hero 表\nSQLModel.metadata.create_all(engine)\n1. 创建 (Create) - 增加数据\nAPI: session.add(), session.commit(), session.refresh()\ndef create_heroes():\n    hero_1 = Hero(name=&quot;蜘蛛侠&quot;, secret_name=&quot;彼得·帕克&quot;, age=18)\n    hero_2 = Hero(name=&quot;钢铁侠&quot;, secret_name=&quot;托尼·斯塔克&quot;, age=45)\n \n    with Session(engine) as session:\n        session.add(hero_1)\n        session.add(hero_2)\n \n        session.commit()  # commit() 才真正将数据写入数据库\n \n        # refresh() 可以用数据库中的新数据（如自动生成的id）更新Python对象\n        session.refresh(hero_1)\n        session.refresh(hero_2)\n \n        print(&quot;创建的英雄:&quot;, hero_1)\n        print(&quot;创建的英雄:&quot;, hero_2)\n \ncreate_heroes()\n2.读取 (Read) - 查询数据\n基本步骤\n\n调用select() 以及它的链式方法得到一个Select对象（可以理解为SQL 语句的抽象表示，这个时候所有的操作都只是在 Python 内存中，没有与数据库进行任何通信）\n通过session.exec()函数把这个Select对象交给session, session 会把这个 Python 对象翻译成真正的 SQL 语句，然后通过数据库连接发送出去并执行。最终得到一个Result对象。\n\nfrom sqlmodel import select\n \ndef read_heroes():\n    with Session(engine) as session:\n        # 查询所有英雄\n        statement = select(Hero)\n        all_heroes = session.exec(statement).all()\n        print(&quot;所有英雄:&quot;, all_heroes)\n \n        # 按条件查询 (查询年龄大于20岁的英雄)\n        statement_filtered = select(Hero).where(Hero.age &gt; 20)\n        older_heroes = session.exec(statement_filtered).all()\n        print(&quot;年龄大于20的英雄:&quot;, older_heroes)\n \n        # 查询单个英雄\n        statement_one = select(Hero).where(Hero.name == &quot;蜘蛛侠&quot;)\n        spiderman = session.exec(statement_one).first()\n        if spiderman:\n            print(&quot;找到的蜘蛛侠:&quot;, spiderman)\n \nread_heroes()\nselect（）常用链式方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法 (Method)作用 (Function)使用场景示例.where(...)过滤数据，只选择满足特定条件的行。这是最常用的方法。选择所有年龄大于 20 岁的英雄，或组合多个条件进行筛选。.order_by(...)排序结果，可以按升序（默认）或降序排列。将查询结果按年龄从小到大或从大到小排序。.limit(...)限制数量，只获取指定数量的结果。只获取查询结果的前 5 名英雄。.offset(...)跳过结果，从指定位置开始获取数据，常用于分页。用于分页功能，例如跳过前 20 条记录，再获取之后的 10 条。.join(...)连接表格，根据外键关系将两个或多个表的数据合并在一起查询。在查询英雄的同时，获取其所在战队的名称等信息。.group_by(...)分组数据，将具有相同值的行组合在一起，通常与聚合函数配合使用。统计每个战队分别有多少名英雄。.distinct()去重结果，确保返回的每一行都是唯一的。获取所有英雄出现过的年龄列表，并去除重复的年龄值。\nResult 对象常用方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法/操作 (Method/Operation)返回什么 (Returns What)使用场景示例.all()一个列表，包含所有结果行。获取所有结果，并且结果集不大时。.first()单个结果对象，或者 None。只需要第一条结果，或者确认结果最多只有一条时。.one()单个结果对象。（若结果不唯一则报错）严格确认结果有且仅有一条时，用于数据完整性检查。.one_or_none()单个结果对象，或者 None。（若结果多于一条则报错）确认结果最多只有一条，但允许为空。比 .one() 更安全。for item in result:在循环的每一次迭代中返回单个结果对象。逐一处理结果，尤其是在结果集很大时，可以节省内存。.scalars()一个新的可迭代对象，它只会产生每行的第一列数据。当你只查询一个字段（如所有英雄的名字）并想要一个干净的值列表时。.mappings()一个新的可迭代对象，它会产生类似字典的行。需要将结果转换为键值对格式，例如用于生成 JSON API 响应。\n3. 更新 (Update) - 修改数据\n流程：先查询，再修改对象的属性，最后提交。\n\nAPI: (查询) + 修改属性 + session.add() + session.commit()\n\ndef update_hero():\n    with Session(engine) as session:\n        # 1. 找到要更新的英雄\n        statement = select(Hero).where(Hero.name == &quot;蜘蛛侠&quot;)\n        hero_to_update = session.exec(statement).first()\n \n        if hero_to_update:\n            # 2. 修改其属性\n            hero_to_update.age = 19\n            # 3. 添加到会话并提交\n            session.add(hero_to_update)\n            session.commit()\n            session.refresh(hero_to_update)\n            print(&quot;更新后的英雄:&quot;, hero_to_update)\n \nupdate_hero()\n4. 删除 (Delete) - 删除数据\n流程：先查询，再从会话中删除，最后提交。\n\nAPI: (查询) + session.delete() + session.commit()\n\ndef delete_hero():\n    with Session(engine) as session:\n        # 1. 找到要删除的英雄\n        statement = select(Hero).where(Hero.name == &quot;钢铁侠&quot;)\n        hero_to_delete = session.exec(statement).first()\n \n        if hero_to_delete:\n            # 2. 从会话中删除\n            session.delete(hero_to_delete)\n            # 3. 提交\n            session.commit()\n            print(&quot;已删除英雄:&quot;, hero_to_delete.name)\n \ndelete_hero()","date":"2025-09-26T06:28:24.000Z"},"articles/wsl2-nat-mode-proxy-configuration-guide":{"slug":"articles/wsl2-nat-mode-proxy-configuration-guide","filePath":"articles/wsl2-nat-mode-proxy-configuration-guide.md","title":"WSL2 NAT模式代理配置指南","links":[],"tags":["wsl2","docker"],"content":"写在前面：为何回归 NAT 模式？\nWSL2 全新的 networkingMode=mirrored（镜像网络模式）在理论上提供了极大的便利，尤其是在 localhost 互通和局域网访问方面。然而，作为一项实验性功能，我在实践中遇到了许多难以排查的网络“坑”，尤其是在与 Docker 结合使用时，出现了连接被拒绝、代理不生效等一系列问题。\n在花费大量时间排错后，我决定回归到 WSL2 久经考验的默认 NAT 模式。这种模式虽然需要一些手动配置，但其行为是可预测且极其稳定的。\n本指南旨在为那些和我一样，选择从 mirrored 模式切换回 NAT 模式，或初次在 NAT 模式下配置代理的用户，提供一套完整、可靠的解决方案。本文将以在 Windows 主机上运行 Clash for Windows 代理程序为例，其默认端口为 7890。\n前置步骤：Windows 主机配置\n在配置 WSL 之前，必须确保 Windows 主机本身已准备就绪。\n1. 查找并固定主机局域网 IP\n代理服务器的目标地址必须固定。\n\n在 Windows PowerShell 或 CMD 中运行 ipconfig。\n在你的主网络适配器（如“以太网适配器”或“无线局域网适配器”）下找到 IPv4 地址。\n建议：在你的路由器管理后台，将此 IP 地址与你的电脑 MAC 地址进行绑定，以防止 IP 地址变动。\n\n\n\n                  \n                  本文将以 192.168.0.100 作为示例主机 IP，以 7890 作为 Clash for Windows 的代理端口。请在实际操作中替换为您自己的地址和端口。\n                  \n                \n\n2. 为代理端口添加入站防火墙规则\n这是最关键的一步。默认情况下，Windows 防火墙可能会阻止来自 WSL（即使它在内部网络）对主机端口的访问，特别是当网络被识别为“公用(Public)”时。创建一个精确的“允许”规则是解决此问题的最佳实践。\n\n在 Windows 搜索框中，输入“高级安全 Windows Defender 防火墙”并打开它。\n在左侧面板中，点击“入站规则”。\n在右侧“操作”面板中，点击“新建规则…”。\n在向导中，按以下步骤操作：\n\n规则类型：选择“端口”，点击“下一步”。\n协议和端口：选择“TCP”，然后在“特定本地端口”中输入您的代理端口，例如 7890。点击“下一步”。\n操作：选择“允许连接”，点击“下一步”。\n配置文件：全部勾选（“域”、“专用”、“公用”），以确保规则在任何网络环境下都生效。点击“下一步”。\n名称：为规则起一个易于识别的名称，例如 Allow WSL Clash Proxy (TCP 7890)。点击“完成”。\n\n\n\n\n\n                  \n                  IMPORTANT\n                  \n                \n\n\n如果不执行此步骤，即使后续所有配置都正确，来自 WSL 和 Docker 的连接也大概率会被 Windows 防火墙丢弃或拒绝。\n\n\n\n步骤一：为 WSL Shell 配置代理\n此配置将影响您在 WSL 终端中直接使用的命令，如 apt, curl, git, wget 等。\n\n编辑 Shell 配置文件。根据您的 Shell 类型选择：\n\n# 如果使用默认的 bash\nnano ~/.bashrc\n \n# 如果使用 zsh\nnano ~/.zshrc\n\n在文件末尾添加以下环境变量。我们同时添加小写和大写版本以获得最佳兼容性。\n\n# Proxy Configuration for Clash for Windows\nexport http_proxy=&quot;http://192.168.0.100:7890&quot;\nexport https_proxy=&quot;http://192.168.0.100:7890&quot;\nexport no_proxy=&quot;localhost,127.0.0.1&quot;\n \nexport HTTP_PROXY=&quot;http://192.168.0.100:7890&quot;\nexport HTTPS_PROXY=&quot;http://192.168.0.100:7890&quot;\nexport NO_PROXY=&quot;localhost,127.0.0.1&quot;\n\n应用配置。关闭并重开终端，或执行 source ~/.bashrc (或 source ~/.zshrc)。\n\n步骤二：为 Docker 环境配置代理\nDocker 的代理配置分为两部分：守护进程（Daemon）和构建/运行环境（Build/Container）。\n1. 配置 Docker 守护进程 (Daemon)\n此配置主要影响 docker pull, docker push 等与 Docker Hub 交互的命令。\n\n\n                  \n                  NOTE\n                  \n                \n\n\n直接修改 /etc/docker/daemon.json 是一种方法，但通过 systemd 的覆盖文件 (override) 是更推荐、更模块化的方式。\n\n\n\n\n使用以下命令，通过一条指令直接创建并写入 systemd 覆盖文件，以避免 vim 操作可能带来的问题。\n\nsudo mkdir -p /etc/systemd/system/docker.service.d/\nsudo tee /etc/systemd/system/docker.service.d/override.conf &gt; /dev/null &lt;&lt;EOF\n[Service]\nEnvironment=&quot;HTTP_PROXY=http://192.168.0.100:7890&quot;\nEnvironment=&quot;HTTPS_PROXY=http://192.168.0.100:7890&quot;\nEnvironment=&quot;NO_PROXY=localhost,127.0.0.1&quot;\nEOF\n\n应用配置并重启 Docker 服务。\n\n# 重新加载 systemd 配置\nsudo systemctl daemon-reload\n# 重启 Docker 服务以加载新的环境变量\nsudo systemctl restart docker\n2. 配置 Docker 构建与运行环境\n此配置影响 Dockerfile 中 RUN 指令（如 RUN apk add ...）以及 docker run 启动的容器内部的网络访问。\n\n修改 Dockerfile\n在 Dockerfile 的 FROM 指令之后，使用 ENV 指令明确设置代理环境变量。\n\nFROM alpine:3.19\n \n# 为构建过程设置代理\nENV HTTP_PROXY=&quot;http://192.168.0.100:7890&quot;\nENV HTTPS_PROXY=&quot;http://192.168.0.100:7890&quot;\nENV NO_PROXY=&quot;localhost,127.0.0.1&quot;\n \n# 现在 RUN 指令就可以通过代理下载软件包了\nRUN apk update &amp;&amp; apk add --no-cache curl git\n \n# ... 其他指令 ...\n\n为运行中的容器设置代理\n如果需要在 docker run 启动的容器内部也使用代理，可以通过 -e 参数传入环境变量。\n\ndocker run -it --rm \\\n  -e HTTP_PROXY=&quot;http://192.168.0.100:7890&quot; \\\n  -e HTTPS_PROXY=&quot;http://192.168.0.100:7890&quot; \\\n  ubuntu:latest \\\n  bash\n遵循以上步骤，即可在 WSL2 的标准 NAT 模式下，为你的开发环境建立一套稳定代理配置。","date":"2025-09-19T10:42:57.000Z"},"friends":{"slug":"friends","filePath":"friends.md","title":"友情链接","links":[],"tags":["blog"],"content":"\n\n                  \n                  Info\n                  \n                \n\n\n互换友链请在这个页面留言。留言时提供以下信息:\n\n博客名称\n博客链接\n\n\n\n","date":"2025-09-06T05:55:51.000Z"}}